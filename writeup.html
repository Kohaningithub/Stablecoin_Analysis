<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>writeup</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="writeup_files/libs/clipboard/clipboard.min.js"></script>
<script src="writeup_files/libs/quarto-html/quarto.js"></script>
<script src="writeup_files/libs/quarto-html/popper.min.js"></script>
<script src="writeup_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="writeup_files/libs/quarto-html/anchor.min.js"></script>
<link href="writeup_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="writeup_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="writeup_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="writeup_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="writeup_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./Users/kohanchen/Documents/2025_Winter/Big_Data/Final/Final_new/img/chicago-booth_logo.jpg" class="img-fluid figure-img"></p>
<figcaption>Chicago Booth Logo</figcaption>
</figure>
</div>
<section id="busn-41204---big-data---section-01" class="level1">
<h1>BUSN 41204 - Big Data - Section 01</h1>
<section id="winter-quarter-2025---professor-dacheng-xiu" class="level2">
<h2 class="anchored" data-anchor-id="winter-quarter-2025---professor-dacheng-xiu">Winter Quarter 2025 - Professor Dacheng Xiu</h2>
</section>
</section>
<section id="stablecoin-stability-analysis" class="level1">
<h1>Stablecoin Stability Analysis:</h1>
<section id="comparing-algorithmic-and-collateralized-designs-during-market-stress" class="level2">
<h2 class="anchored" data-anchor-id="comparing-algorithmic-and-collateralized-designs-during-market-stress">Comparing Algorithmic and Collateralized Designs During Market Stress</h2>
<section id="march-15-2025" class="level3">
<h3 class="anchored" data-anchor-id="march-15-2025">March 15, 2025</h3>
</section>
<section id="by-kohan-chen" class="level3">
<h3 class="anchored" data-anchor-id="by-kohan-chen">By Kohan Chen</h3>
<hr>
</section>
</section>
<section id="executive-summary" class="level2">
<h2 class="anchored" data-anchor-id="executive-summary">1. Executive Summary</h2>
<p>This research examines how stablecoins behaved during the Terra/Luna collapse of May 2022, offering a window into the strengths and weaknesses of different stablecoin designs under extreme market stress. By analyzing over 70 million transactions and daily price data for five major stablecoins (USDT, USDC, DAI, USTC, PAX), we uncovered striking differences between algorithmic and collateralized approaches to stability.</p>
<p>The findings reveal a stark contrast: while collateralized stablecoins maintained their pegs with remarkable consistency throughout the crisis, the algorithmic USTC suffered catastrophic and irreversible failure. This collapse wasn’t gradual but rather exhibited a “cliff edge” pattern - USTC appeared stable until just before its sudden breakdown, with virtually no warning signs in traditional metrics. This abrupt transition challenges conventional monitoring approaches and suggests that stability isn’t a spectrum but rather a binary state with distinct thresholds.</p>
<p>Perhaps most surprising was the “stability paradox” - the most stable tokens were actually the least predictable in statistical terms. Well-functioning stablecoins like USDC maintained such tight peg control that their tiny deviations appeared random, resulting in poor regression performance despite excellent stability outcomes. Meanwhile, USTC showed high statistical predictability precisely because its instability followed clear patterns, particularly its strong dependence on previous deviations that created a self-reinforcing downward spiral once the collapse began.</p>
<p>The crisis also revealed important insights about contagion risk in cryptocurrency markets. Despite USTC’s dramatic failure, other stablecoins showed remarkable resilience with minimal spillover effects. This containment suggests effective market compartmentalization and fundamental differences in stability mechanisms that prevented crisis transmission across the stablecoin ecosystem.</p>
<p>These findings have significant implications for how we design, monitor, and regulate stablecoins. The superior performance of collateralized designs suggests that effective stablecoins should incorporate robust external backing rather than relying solely on algorithmic mechanisms. The “cliff edge” nature of failures indicates that monitoring systems should focus on identifying critical thresholds rather than tracking gradual changes. And the stark performance differences between stablecoin types suggests that regulatory frameworks should distinguish between these categories, with potentially stricter requirements for algorithmic tokens given their demonstrated vulnerability.</p>
<p>By combining multiple analytical approaches, from decision trees and random forests to LASSO regression and clustering analysis, this research provides a comprehensive framework for understanding stablecoin stability dynamics. The insights offered here can help designers build more resilient systems, users make more informed choices, and regulators develop more effective oversight for these increasingly important financial instruments.</p>
</section>
<section id="introduction-to-stablecoin-stability-analysis" class="level2">
<h2 class="anchored" data-anchor-id="introduction-to-stablecoin-stability-analysis">2. Introduction to Stablecoin Stability Analysis</h2>
<section id="dataset-overview-and-research-context" class="level3">
<h3 class="anchored" data-anchor-id="dataset-overview-and-research-context">Dataset Overview and Research Context</h3>
<p>This research investigates the stability dynamics of stablecoins through a comprehensive analysis of price deviations, volatility patterns, and network characteristics. The dataset encompasses daily observations of five major stablecoins (USDT, USDC, DAI, UST/USTC, PAX) and WLUNA from April to November 2022, a period that includes the significant Terra/Luna collapse in May 2022.</p>
<p>The original dataset, provided by researchers from U Manitoba and UT Dallas, contains three primary components:</p>
<ol type="1">
<li><strong>Transaction data</strong>: Over 70 million ERC20 transactions between Ethereum addresses and smart contracts</li>
<li><strong>Price data</strong>: Daily OHLC (open, high, low, close) prices in USD for each token</li>
<li><strong>Event data</strong>: Timestamps and descriptions of significant events affecting the stablecoin ecosystem</li>
</ol>
<p>From this raw data, this project derived several analytical metrics: - <strong>Stability metrics</strong>: Daily price deviations from the peg, volatility measurements, and trading volumes - <strong>Network metrics</strong>: Graph-based measurements calculated from transaction networks, including density, reciprocity, modularity, and various centralization metrics</p>
<p>This combination of raw data and derived metrics allows us to explore not only the price behavior of stablecoins but also how their underlying transaction networks relate to stability outcomes. The period covered is particularly valuable as it captures both the lead-up to and aftermath of the Terra/Luna crash, when UST (TerraUSD) lost its 1 USD peg in early May 2022, providing a natural experiment to test stability mechanisms under extreme stress conditions.</p>
<p>Our analysis focuses on understanding how different stablecoin designs (algorithmic vs.&nbsp;collateralized) respond to market pressures, identifying early warning signals of stability issues, and determining which network characteristics correlate with resilience during market stress events.</p>
</section>
<section id="research-questions-and-analysis-roadmap" class="level3">
<h3 class="anchored" data-anchor-id="research-questions-and-analysis-roadmap">Research Questions and Analysis Roadmap</h3>
<p>This research explores the complex dynamics of stablecoin stability through five interconnected questions that guide this analytical approach. First, I investigate how different stablecoins maintain their pegs during both normal and stressed market conditions, examining the distinct patterns of deviation across algorithmic and collateralized designs. This stability characterization forms the foundation of the analysis, incorporating hierarchical clustering, decision tree modeling, detailed peg deviation analysis, and volatility pattern identification to build a comprehensive picture of stability mechanisms.</p>
<p>The second question delves into the relationship between network structure and stablecoin stability, analyzing how transaction patterns and network metrics correlate with stability outcomes. By examining network size, activity levels, and structural evolution over time, this research uncover important connections between on-chain behavior and price stability that provide insights into the social dynamics underlying stablecoin markets.</p>
<p>The third research focus addresses the development of early warning systems for stability issues, employing forward chain validation techniques to test predictive models under realistic conditions. This analysis evaluates model performance across different stability regimes and identifies the limitations of prediction approaches, particularly during rapid transition events. The findings help establish practical frameworks for monitoring stability risks before they manifest as significant price deviations.</p>
<p>The fourth question centers on a detailed case study of the USTC collapse, breaking down this critical event into three distinct phases for granular analysis. By examining early warning signals, model performance during the crisis, and the mechanics of the collapse, the research extract valuable lessons about algorithmic stablecoin vulnerabilities and the challenges of predicting critical transitions in complex financial systems.</p>
<p>Finally, I investigate broader market behavior patterns during stability events, analyzing transaction patterns, identifying distinct market regimes, and assessing contagion effects across the stablecoin ecosystem. This market-level perspective complements token-specific analyses by revealing how different segments of the market interact during periods of stress, providing insights into systemic risk and resilience factors. Throughout all these analyses, the research maintain a particular focus on comparing algorithmic stablecoins with collateralized alternatives, highlighting the relative strengths and vulnerabilities of different design approaches under market stress.</p>
</section>
<section id="analytical-approach" class="level3">
<h3 class="anchored" data-anchor-id="analytical-approach">Analytical Approach</h3>
<p>To address these research questions, this project employed a multi-model analytical framework with five complementary approaches:</p>
<section id="decision-trees" class="level4">
<h4 class="anchored" data-anchor-id="decision-trees">1. Decision Trees</h4>
<p>Decision trees were used to identify threshold values and decision rules that characterize stability classes. This approach provides interpretable insights into the factors that determine whether a stablecoin remains stable, becomes unstable, or depegs entirely. The trees were constructed for each stablecoin separately to capture token-specific stability dynamics.</p>
</section>
<section id="random-forests" class="level4">
<h4 class="anchored" data-anchor-id="random-forests">2. Random Forests</h4>
<p>Random forests were implemented to build high-performance predictive models that capture complex, non-linear relationships between network structure and stablecoin stability. This ensemble approach improves prediction accuracy while handling the high dimensionality of the feature space.</p>
</section>
<section id="clustering-for-market-regimes" class="level4">
<h4 class="anchored" data-anchor-id="clustering-for-market-regimes">3. Clustering for Market Regimes</h4>
<p>Clustering analysis was used to discover distinct market regimes in stablecoin behavior and understand how different stablecoins behave in each regime. This unsupervised approach helps identify patterns that might not be apparent in supervised learning methods.</p>
</section>
<section id="lassoridge-regression" class="level4">
<h4 class="anchored" data-anchor-id="lassoridge-regression">4. LASSO/Ridge Regression</h4>
<p>LASSO and Ridge regression techniques were applied to perform feature selection while handling multicollinearity among predictors. These regularization approaches help identify the most important features while preventing overfitting.</p>
<p>This multi-model approach allows us to leverage the strengths of different methodologies: interpretability from decision trees, predictive power from random forests, pattern discovery from clustering, and feature selection from LASSO/Ridge regression. By comparing results across models, we can identify consistent patterns and factors that influence stablecoin stability across different analytical frameworks.</p>
<p>Below, we will provide some exploratory data analysis on the dataset, and then address the research questions one by one.</p>
</section>
</section>
</section>
<section id="exploratory-data-analysis" class="level2">
<h2 class="anchored" data-anchor-id="exploratory-data-analysis">3. Exploratory Data Analysis</h2>
<p>Our exploratory analysis begins with an examination of the stability characteristics of the stablecoins in our dataset, focusing on their peg deviations, volatility patterns, and network metrics over time.</p>
<section id="note-on-wluna" class="level3">
<h3 class="anchored" data-anchor-id="note-on-wluna">Note on WLUNA</h3>
<p>While dataset includes WLUNA (Wrapped LUNA), it’s important to note that WLUNA is not a stablecoin. Unlike USDT, USDC, DAI, PAX, and USTC which are designed to maintain a $1.00 peg, WLUNA is a wrapped version of the LUNA token that was designed to be used on the Ethereum blockchain.</p>
</section>
<section id="stability-metrics-overview" class="level3">
<h3 class="anchored" data-anchor-id="stability-metrics-overview">3.1 Stability Metrics Overview</h3>
<p>First, let’s examine the basic stability metrics for each stablecoin in our dataset:</p>
<section id="hierarchical-clustering-analysis" class="level4">
<h4 class="anchored" data-anchor-id="hierarchical-clustering-analysis">Hierarchical Clustering Analysis</h4>
<p>Before examining individual metrics, we performed hierarchical clustering to identify natural groupings in stablecoin behavior based on their stability characteristics:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/hierarchical_clustering.png" class="img-fluid figure-img"></p>
<figcaption>Hierarchical Clustering of Stablecoins</figcaption>
</figure>
</div>
<p>The dendrogram reveals two distinct clusters that align with stablecoin design types: - <strong>Cluster 1 (Collateralized)</strong>: USDT, USDC, DAI, and PAX form a tight cluster, indicating similar stability behavior - <strong>Cluster 2 (Algorithmic)</strong>: USTC stands completely separate, confirming fundamentally different behavior</p>
<p>To better understand these differences, we examined the relationship between mean and maximum peg deviations:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/stablecoin_clusters.png" class="img-fluid figure-img"></p>
<figcaption>Stablecoin Clusters by Stability Behavior</figcaption>
</figure>
</div>
<p>This visualization reveals clear stability patterns:</p>
<p><strong>Collateralized Stablecoins</strong> (USDT, USDC, DAI, PAX) cluster tightly in the lower-left corner, showing both low mean and maximum deviations, indicating consistent peg maintenance</p>
<p><strong>Algorithmic Stablecoin</strong> (USTC) appears as an extreme outlier in the upper-right, demonstrating both high mean deviation (~0.8) and maximum deviation (~1.0), indicating complete depegging</p>
<p>This clustering analysis quantifies the magnitude of difference between stablecoin designs - USTC’s mean deviation was approximately 80 times larger than the collateralized stablecoins, demonstrating the fundamental vulnerability of its algorithmic design.</p>
<p>To further understand the stability characteristics, we examined the relationship between mean volatility and stress ratio (maximum deviation relative to average deviation):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/stablecoin_volatility_clusters.png" class="img-fluid figure-img"></p>
<figcaption>Stablecoin Clusters by Volatility and Stress Ratio</figcaption>
</figure>
</div>
<p>The decision tree analysis revealed a remarkably simple yet powerful pattern in stablecoin stability classification. Despite having access to a rich array of potential predictors—including volatility metrics, trading volume data, network structure indicators, and temporal features—the trees consistently identified peg deviation as the sole decisive factor for classification. This striking parsimony in feature selection is particularly noteworthy considering I employed unpruned trees, which would have readily incorporated additional decision paths had they meaningfully improved classification accuracy. The consistency of this finding across different tokens suggests a fundamental truth about stablecoin stability: that despite the complex mechanisms underlying different designs, their stability states can be reliably determined through simple deviation thresholds. This challenges the conventional wisdom that sophisticated monitoring systems tracking multiple indicators are necessary for effective stability assessment. Instead, the analysis points to a more discrete view of stability—one where tokens exist in clearly defined states rather than along a continuous spectrum of stability, lending further support to the “cliff edge” hypothesis that has emerged throughout analyses.</p>
</section>
<section id="peg-deviation-analysis" class="level4">
<h4 class="anchored" data-anchor-id="peg-deviation-analysis">Peg Deviation Analysis</h4>
<p>The primary measure of stablecoin stability is its deviation from the intended peg value (typically $1.00). The following figure shows the absolute peg deviation for each stablecoin over the study period:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/peg_deviation_by_token.png" class="img-fluid figure-img"></p>
<figcaption>Peg Deviation by Token</figcaption>
</figure>
</div>
<p>This visualization reveals several key insights about stablecoin performance during the study period. USDT and USDC demonstrate the strongest peg stability throughout the timeline, maintaining near-perfect alignment with their target value, which suggests both substantial market trust and robust collateralization mechanisms supporting these tokens. DAI and PAX, while still performing admirably, exhibit slightly higher fluctuations in their peg values, though their deviations remain well-managed within a stable range that preserves their functional utility as stable assets. In stark contrast, USTC (formerly UST) experienced a catastrophic depeg during the Terra/Luna crash in May 2022, with deviations exceeding 90% from its intended value, dramatically illustrating the fundamental weakness of algorithmic stablecoin designs when subjected to extreme market stress. WLUNA appears to have missing data in the visualization, which is expected given that WLUNA is not a stablecoin and was never designed to maintain a $1.00 peg, making it an inappropriate comparison point for stability analysis. The dramatic performance difference between USTC and the collateralized stablecoins highlights the fundamental structural distinctions between algorithmic and collateralized stablecoin designs when faced with extraordinary market pressures.</p>
</section>
<section id="volatility-patterns" class="level4">
<h4 class="anchored" data-anchor-id="volatility-patterns">Volatility Patterns</h4>
<p>Volatility provides another lens through which to examine stablecoin stability. The following figure shows the daily price volatility for each token:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/volatility_by_token.png" class="img-fluid figure-img"></p>
<figcaption>Volatility by Token</figcaption>
</figure>
</div>
<p>Volatility provides another lens through which to examine stablecoin stability. The daily price volatility analysis across tokens reveals distinct patterns that further differentiate algorithmic from collateralized designs. USTC exhibits extreme volatility spikes during the crash period, with fluctuations orders of magnitude larger than other tokens, highlighting the catastrophic breakdown of its stability mechanism. In stark contrast, collateralized stablecoins like USDT and USDC maintain consistently low volatility throughout the study period, demonstrating their robust peg maintenance even during market turbulence. DAI shows slightly elevated volatility during market stress periods but quickly returns to baseline, suggesting that its decentralized collateral model, while somewhat more responsive to market conditions, remains fundamentally resilient. PAX exhibits moderate volatility fluctuations similar to DAI but with slightly larger swings, potentially indicating a more reactive collateral management approach. WLUNA shows extremely high volatility consistent with its collapse alongside the Terra ecosystem, though this behavior is expected given its role as a governance token rather than a stablecoin. Throughout the dataset, volatility clustering is evident, with periods of high volatility tending to persist across multiple days, suggesting that stability stress events typically unfold over time rather than manifesting as isolated incidents.</p>
</section>
</section>
<section id="network-metrics-analysis" class="level3">
<h3 class="anchored" data-anchor-id="network-metrics-analysis">3.2 Network Metrics Analysis</h3>
<p>Next, we examine the network characteristics derived from the transaction data:</p>
<section id="network-size-and-activity" class="level4">
<h4 class="anchored" data-anchor-id="network-size-and-activity">Network Size and Activity</h4>
<p>The following figures show the number of nodes (unique addresses) and edges (transactions) in each stablecoin’s network over the three periods shown in the data:</p>
<ol type="1">
<li><p><strong>Pre-crash</strong> (April 1 - May 7, 2022)</p></li>
<li><p><strong>Early crash</strong> (May 8 - May 15, 2022)</p></li>
<li><p><strong>Late crash/early recovery</strong> (May 16 - June 15, 2022)</p></li>
</ol>
<p><img src="img/nodes_by_token.png" class="img-fluid" alt="Network Nodes by Token"> <img src="img/edges_by_token.png" class="img-fluid" alt="Network Edges by Token"></p>
<p>The network analysis reveals fascinating patterns in transaction behavior across different stablecoin ecosystems during the crisis period. USDT consistently maintains the largest and most active network throughout all periods, reflecting its dominant market position and widespread adoption across the cryptocurrency ecosystem. Its transaction volume dwarfs other stablecoins, demonstrating its central role in crypto markets regardless of stability events. USDC shows steady growth in network size throughout the study period, with transaction activity actually increasing during and after the crash, reinforcing its emerging role as a trusted collateral-backed alternative gaining market share during uncertainty. USTC’s network metrics tell a compelling story of collapse: after experiencing a dramatic surge in activity during the initial crash period—likely reflecting panic selling and liquidations—its transaction activity dropped precipitously below pre-crash levels in the aftermath, reflecting a profound loss of network participation and diminished market interest following its failure. DAI maintains a relatively stable network size across all periods, indicating consistent usage despite broader market fluctuations, which speaks to the resilience of its decentralized stability model. Perhaps most intriguingly, WLUNA exhibits a counterintuitive pattern compared to USTC: while both tokens collapsed in value, WLUNA’s network activity dramatically increased post-crash, suggesting continued speculative trading or ecosystem reorganization activities even after the price collapse. These contrasting network behaviors reveal how different token designs respond to market stress, with collateralized stablecoins maintaining or growing their networks while algorithmic stablecoins experience dramatic participation shifts during crises.</p>
</section>
<section id="network-structure-metrics" class="level4">
<h4 class="anchored" data-anchor-id="network-structure-metrics">Network Structure Metrics</h4>
<p>We analyzed complex network metrics to understand the structural characteristics of each stablecoin’s transaction network:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/density_by_token.png" class="img-fluid figure-img"></p>
<figcaption>Network Density by Token</figcaption>
</figure>
</div>
<ul>
<li><p><strong>Network density patterns</strong> show large differences between tokens:</p>
<ul>
<li><p><strong>WLUNA</strong> exhibits an extremely high density spike (0.05) in the pre-crash period, indicating a tightly interconnected network where many possible connections between addresses were realized. This density dropped dramatically during and after the crash.</p></li>
<li><p><strong>PAX</strong> maintains the most consistently dense network among stablecoins, with density increasing post-crash, suggesting a consolidation of transaction patterns.</p></li>
<li><p><strong>UST</strong> shows low density pre-crash that increases post-crash, likely reflecting the concentration of remaining activity among a smaller set of addresses after many participants exited.</p></li>
<li><p><strong>USDT, USDC, and DAI</strong> maintain very low network density throughout all periods, which is expected for large-scale networks with many participants.</p></li>
</ul></li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/modularity_by_token.png" class="img-fluid figure-img"></p>
<figcaption>Network Modularity by Token</figcaption>
</figure>
</div>
<ul>
<li><p><strong>Modularity analysis</strong> reveals complementary insights:</p>
<ul>
<li><p><strong>USDT</strong> maintains the highest modularity across all periods, indicating a highly compartmentalized network with distinct community structures despite its low density. This combination suggests a network with specialized usage patterns and institutional segregation.</p></li>
<li><p><strong>USDC</strong> shows moderately high modularity with minimal changes across periods, reflecting stable community structures.</p></li>
<li><p><strong>DAI and PAX</strong> exhibit similar modularity patterns, suggesting more integrated networks with fewer distinct communities than the larger stablecoins.</p></li>
<li><p><strong>UST</strong> shows the lowest modularity among stablecoins, which counterintuitively suggests a more integrated network structure. This lower compartmentalization may have contributed to its vulnerability during the crash, as contagion could spread more easily through the network.</p></li>
</ul></li>
<li><p><strong>The density-modularity relationship</strong> provides key insights into network resilience:</p>
<ul>
<li><p><strong>USDT</strong> combines low density with high modularity, creating a structure of distinct, specialized communities that limits contagion while maintaining efficiency.</p></li>
<li><p><strong>PAX</strong> shows higher density with moderate modularity, suggesting a smaller but more interconnected user base with some community structure.</p></li>
<li><p><strong>UST’s</strong> combination of low density and low modularity created a vulnerable network structure where shocks could propagate more easily without the buffering effect of distinct communities.</p></li>
<li><p><strong>WLUNA’s</strong> extreme pre-crash density with moderate modularity suggests a highly speculative trading pattern that collapsed during the crash.</p></li>
</ul></li>
</ul>
<p>These patterns suggest that the optimal network structure for stability combines moderate-to-high modularity (to contain contagion) with appropriate density for the network size. The persistence of community structures even during market stress indicates that established usage patterns remain resilient, while density fluctuations reflect changing transaction behaviors.</p>
<p>Collateralized stablecoins maintain more consistent network structures throughout market phases, while algorithmic stablecoins show more dramatic structural changes. The combination of appropriate density scaling with high modularity (as seen in USDT) appears to provide the most resilient network structure for maintaining stability during market stress.</p>
</section>
</section>
<section id="temporal-patterns-and-market-phases" class="level3">
<h3 class="anchored" data-anchor-id="temporal-patterns-and-market-phases">3.3 Temporal Patterns and Market Phases</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/peg_deviation_log.png" class="img-fluid figure-img"></p>
<figcaption>Mean Peg Deviation by Period (Log Scale)</figcaption>
</figure>
</div>
<p>This log-scale visualization reveals dramatic differences in how stablecoins responded to market stress:</p>
<ul>
<li><p><strong>USTC</strong> suffered a complete depeg during the crash period, with its mean deviation surging by orders of magnitude. Even in the post-crash period, it failed to recover, confirming its irreversible collapse.</p></li>
<li><p><strong>Collateralized stablecoins</strong> (USDT, USDC) maintained relatively stable pegs even during the height of the crisis. USDT saw a decrease in deviation during the crash but has shown certain rocover after the crash.</p></li>
<li><p><strong>DAI</strong> also maintained remarkily stable pegs even during the crisis, with the slight increase over the period.</p></li>
<li><p><strong>PAX</strong> exhibited slightly higher deviations during the cirsis but quickly recover to the original level afte the crisis.</p></li>
</ul>
<p>For a clearer view of the non-USTC tokens, we can examine them separately:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/peg_deviation_non_ustc.png" class="img-fluid figure-img"></p>
<figcaption>Mean Peg Deviation by Period (Excluding USTC)</figcaption>
</figure>
</div>
<p>Without USTC’s extreme values, we can see more subtle patterns:</p>
<ul>
<li><p><strong>DAI’s</strong> maintained relatively stable deviations across all periods, with only minor fluctuations during market stress</p></li>
<li><p><strong>PAX</strong> exhibited the highest mean deviation among the stablecoins, particularly in the pre-crash and post-crash periods, suggesting a weaker peg maintenance mechanism.</p></li>
<li><p><strong>USDC</strong> consistently demonstrated the lowest deviation, reinforcing its reputation as the most stable among the group.</p></li>
<li><p><strong>USDT</strong> showed a significant spike in deviation during the crash period, indicating temporary market stress or liquidity concerns. However, it reverted to more stable levels post-crash.</p></li>
</ul>
<p>To compare relative stability impacts across tokens regardless of magnitude, we normalized each token’s deviation as a percentage of its maximum:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/peg_deviation_normalized.png" class="img-fluid figure-img"></p>
<figcaption>Normalized Peg Deviation by Period</figcaption>
</figure>
</div>
<p>From the normalized plot, it shows that all stablecoins experienced their maximum deviations during the crash period.</p>
<ul>
<li><p><strong>DAI</strong> exhibited consistent peg deviations across all periods, with relatively small fluctuations post-crash.</p></li>
<li><p><strong>PAX</strong> experienced a sharp reduction in deviation during the crash period, but shows strong post-crash recovery.</p></li>
<li><p><strong>USDC</strong> shows a notable decrease in normalized peg deviation during the crash period compared to the pre-crash period, suggesting that it remained relatively stable and even improved its peg adherence during market turmoil.</p></li>
<li><p><strong>USDT</strong> exhibits a sharp increase in deviation during the crash period, indicating that it temporarily lost its peg more significantly than in the pre-crash period.</p></li>
</ul>
<p>Collateralized stablecoins (USDC, USDT, DAI, PAX) demonstrated stronger resilience during market stress, with USDC maintaining the most stability. USDT temporarily lost its peg but recovered, while PAX showed strong post-crash recovery. In contrast, USTC, an algorithmic stablecoin, failed catastrophically and never regained its peg, highlighting the structural vulnerability of algorithmic designs.</p>
</section>
</section>
<section id="predictive-modeling-and-crisis-analysis" class="level2">
<h2 class="anchored" data-anchor-id="predictive-modeling-and-crisis-analysis">4. Predictive Modeling and Crisis Analysis</h2>
<section id="ustc-collapse-case-study" class="level3">
<h3 class="anchored" data-anchor-id="ustc-collapse-case-study">4.1 USTC Collapse Case Study</h3>
</section>
<section id="ustc-mechanics-of-collapse" class="level3">
<h3 class="anchored" data-anchor-id="ustc-mechanics-of-collapse">USTC: Mechanics of Collapse</h3>
<p>To better understand the mechanics of USTC’s collapse, we conducted a detailed analysis of its stability metrics during the critical period:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/ustc_peg_deviation.png" class="img-fluid figure-img"></p>
<figcaption>USTC (Terra UST) Peg Deviation Over Time</figcaption>
</figure>
</div>
<p>The peg deviation analysis reveals three distinct phases:</p>
<ol type="1">
<li><p><strong>Pre-crash Stability</strong> (April 1 - May 7): USTC maintained a relatively stable peg with minimal deviations, suggesting market confidence in its algorithmic stability mechanism.</p></li>
<li><p><strong>Catastrophic Depegging</strong> (May 8-15): A sudden and severe loss of peg occurred, with deviation rapidly increasing from near zero to almost 100%, indicating complete failure of the stability mechanism.</p></li>
<li><p><strong>Post-crash Failure</strong> (May 16 onward): USTC never recovered its peg, with deviations consistently remaining above 95%, demonstrating the irreversible nature of the algorithmic stablecoin’s collapse.</p></li>
</ol>
<p>Summary statistics by period:</p>
<ul>
<li><p>Pre-crash: Mean deviation 0.00018, Max deviation 0.003</p></li>
<li><p>Crash period: Mean deviation 0.4592, Max deviation 0.8460</p></li>
<li><p>Post-crash: Mean deviation 0.9639, Max deviation 0.9935</p></li>
</ul>
</section>
<section id="early-warning-signals" class="level3">
<h3 class="anchored" data-anchor-id="early-warning-signals">Early Warning Signals</h3>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/ustc_early_warning_signals.png" class="img-fluid figure-img"></p>
<figcaption>USTC Early Warning Signals</figcaption>
</figure>
</div>
<p>Our analysis reveals a concerning characteristic of USTC’s collapse - the relative absence of clear warning signals. The peg deviation remained remarkably stable until just before the crash, with almost no indication of the impending failure. While there were some minor volatility spikes in the pre-crash period, these were not notably different from normal market fluctuations.</p>
<p>This “cliff edge” behavior is particularly troubling from a stability monitoring perspective. Rather than showing gradual deterioration that might have allowed for preventive measures, USTC maintained an appearance of stability almost until the moment of catastrophic failure. This suggests that traditional early warning metrics based on peg deviation or volatility patterns might be insufficient for detecting vulnerabilities in algorithmic stablecoins.</p>
<p>The sudden transition from apparent stability to complete failure highlights a fundamental risk of algorithmic stablecoin designs - their potential for abrupt, non-linear responses to market pressures. Once the stability mechanism began to fail, the collapse was both rapid and irreversible, offering little opportunity for intervention.</p>
</section>
<section id="ustc-early-warning-system-development" class="level3">
<h3 class="anchored" data-anchor-id="ustc-early-warning-system-development">USTC: Early Warning System Development</h3>
<p>Given the apparent lack of clear warning signals, we employed a forward-chain validation approach to determine if more sophisticated quantitative methods might detect subtle patterns that visual analysis missed. This methodology uses a rolling 14-day window of historical data to make daily predictions of peg deviation.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/forward_chain_ustc.png" class="img-fluid figure-img"></p>
<figcaption>Forward Chain Validation Results</figcaption>
</figure>
</div>
<p>The solid red line shows actual peg deviation, while the dashed green line shows our model’s predictions. Despite achieving strong statistical performance (R² = 0.95, RMSE = 0.074467), the model’s predictive accuracy varies across different phases of the collapse:</p>
<ol type="1">
<li><p><strong>Pre-crash Period</strong>: The model correctly predicted the stable peg, which was straightforward given the near-zero deviation.</p></li>
<li><p><strong>Crash Point</strong>: While the model did anticipate an increase in peg deviation, it underestimated the severity and speed of the rise, predicting a more gradual deviation than the actual sharp breakdown that occurred.</p></li>
<li><p><strong>Post-crash</strong>: Once the collapse was underway, the model adapted quickly, closely tracking the actual deviation.</p></li>
<li><p><strong>Recovery Attempts</strong>: The model maintained high accuracy in predicting the prolonged depegged state, indicating that once a stablecoin collapses, its new equilibrium becomes easier to model.</p></li>
</ol>
<p>These findings suggest that while the model can detect the onset of instability, it struggles to predict the severity and speed of the critical transition point. This aligns with the “cliff edge” nature of algorithmic stablecoin failures - while warning signs may be detectable, the actual collapse can be more sudden and severe than models anticipate, reinforcing the structural vulnerabilities of such designs.</p>
</section>
<section id="predictive-modeling" class="level3">
<h3 class="anchored" data-anchor-id="predictive-modeling">Predictive Modeling</h3>
<p>Given the apparent lack of clear warning signals, we employed a forward-chain validation approach to determine if more sophisticated quantitative methods might detect subtle patterns that visual analysis missed. This methodology uses a rolling 14-day window of historical data to make daily predictions of peg deviation.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/forward_chain_ustc.png" class="img-fluid figure-img"></p>
<figcaption>Forward Chain Validation Results</figcaption>
</figure>
</div>
<p>The solid red line shows actual peg deviation, while the dashed green line shows our model’s predictions. Despite achieving strong statistical performance (R² = 0.95, RMSE = 0.074467), the model’s predictive accuracy varies across different phases of the collapse:</p>
<ol type="1">
<li><p><strong>Pre-crash Period</strong>: The model correctly predicted the stable peg, which was straightforward given the near-zero deviation.</p></li>
<li><p><strong>Crash Point</strong>: While the model did anticipate an increase in peg deviation, it underestimated the severity and speed of the rise, predicting a more gradual deviation than the actual sharp breakdown that occurred.</p></li>
<li><p><strong>Post-crash</strong>: Once the collapse was underway, the model adapted quickly, closely tracking the actual deviation.</p></li>
<li><p><strong>Recovery Attempts</strong>: The model maintained high accuracy in predicting the prolonged depegged state, indicating that once a stablecoin collapses, its new equilibrium becomes easier to model.</p></li>
</ol>
<p>These findings suggest that while the model can detect the onset of instability, it struggles to predict the severity and speed of the critical transition point. This aligns with the “cliff edge” nature of algorithmic stablecoin failures - while warning signs may be detectable, the actual collapse can be more sudden and severe than models anticipate, reinforcing the structural vulnerabilities of such designs.</p>
</section>
<section id="transaction-pattern-analysis" class="level3">
<h3 class="anchored" data-anchor-id="transaction-pattern-analysis">4.2 Transaction Pattern Analysis</h3>
<p>To understand the behavioral dynamics during the crash, we analyzed transaction patterns using topic modeling. This revealed distinct types of market activity, from routine trading operations to crisis responses. The analysis identified ten key transaction patterns: Exchange Deposits, Arbitrage Activity, Liquidations, Whale Transfers, Retail Panic, Institutional Activity, Cross-chain Bridges, DEX Swaps, Lending Platforms, and Staking Withdrawals.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/transaction_pattern_heatmap.png" class="img-fluid figure-img"></p>
<figcaption>Transaction Pattern Heatmap Over Time</figcaption>
</figure>
</div>
<p>The temporal evolution of these patterns reveals a clear sequence of market behaviors around the crash. The pre-crash period (late April to early May) shows concentrated whale transfers and high arbitrage activity, suggesting early signs of market stress. A notable spike in staking withdrawals followed, indicating growing concern among stakeholders. This sequence of behaviors might represent early warning signals of the impending crisis.</p>
<p>During the crash period (marked by the dashed lines, May 8-15), we observe a complex cascade of activities: retail panic emerged first, followed by intense activity across lending platforms, cross-chain bridges, and DEX swaps. This suggests market participants were simultaneously attempting multiple strategies - seeking liquidity through lending platforms, moving assets across chains, and trying to exit through DEX trades. Institutional activity peaked slightly later, possibly representing delayed but more coordinated responses to the crisis.</p>
<p>The post-crash period (after May 15) shows a dramatic shift in behavior patterns. Exchange deposits become the dominant activity, indicating a persistent exodus from the ecosystem. Meanwhile, liquidations intensified, suggesting forced selling as positions became unsustainable. Most other activities, including institutional involvement and DEX swaps, significantly diminished, marking a fundamental breakdown in normal market functioning.</p>
<p>These transaction patterns provide valuable insights into the mechanics of a stablecoin collapse, showing how different market participants react and how their behaviors can amplify market stress. While the shift from normal trading to panic-driven patterns could theoretically serve as an early warning indicator, the analysis suggests that these behavioral changes often occur too rapidly for effective intervention, particularly in algorithmic stablecoin systems.</p>
</section>
<section id="market-regime-analysis-and-early-warning-indicators" class="level3">
<h3 class="anchored" data-anchor-id="market-regime-analysis-and-early-warning-indicators">4.3 Market Regime Analysis and Early Warning Indicators</h3>
<p>To identify patterns that might serve as early warning indicators for future stability events, we applied topic modeling to discover distinct market regimes in the stablecoin ecosystem. This analysis revealed two primary patterns, visualized in the temporal evolution of market regimes over study period:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/token_pattern_associations.png" class="img-fluid figure-img"></p>
<figcaption>Token Associations with Market Regimes</figcaption>
</figure>
</div>
<p>The quantitative analysis of token associations with each market regime reveals the stark contrast between USTC and other stablecoins. While USTC showed overwhelming association (0.992) with the crisis pattern, other stablecoins maintained strong stability pattern associations, with USDC showing the strongest stability alignment (0.001194), followed by WLUNA (0.001113), DAI (0.001444), and USDT (0.001508). PAX showed slightly higher crisis association (0.002343) but still remained firmly within the stable regime. These quantitative relationships support our qualitative observations about the isolation of the Terra/Luna crisis from the broader stablecoin ecosystem.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/pattern_strength_time.png" class="img-fluid figure-img"></p>
<figcaption>Market Regime Strength Over Time</figcaption>
</figure>
</div>
<p>The pre-crash period was dominated by what we term the “Stability Pattern” (shown in turquoise), characterized by low volatility and consistent peg maintenance. This pattern showed strong association with established stablecoins, reflecting their reliable performance during normal market conditions. However, the gradual erosion of this stability pattern in early May 2022 would prove to be a crucial early warning signal.</p>
<p>As the Terra/Luna ecosystem began to show stress, a distinct “Crisis Pattern” (shown in red) emerged sharply during the crash period. The abrupt transition from stability to crisis patterns during May 8-15 marked a critical phase shift in the stablecoin ecosystem.</p>
<p>Perhaps most notably, our analysis revealed several potential early warning indicators that preceded the full-scale crisis. The stability pattern showed subtle but detectable deterioration several days before the crash, while the crisis pattern began strengthening even before USTC’s dramatic depegging. The transition between these patterns was not gradual but rather accelerated rapidly once certain thresholds were crossed, suggesting the existence of tipping points in stablecoin stability.</p>
<p>The analysis also provided insights into contagion effects within the stablecoin ecosystem. While USTC experienced catastrophic failure, other stablecoins showed remarkable resilience. USDT and USDC maintained strong alignment with the stability pattern throughout the crisis, demonstrating the robustness of their collateralized designs. DAI experienced a brief increase in crisis pattern association but quickly reverted to stability, highlighting the effectiveness of its decentralized collateral model under stress.</p>
<p>The post-crash period revealed lasting changes in market dynamics. The crisis pattern remained elevated well after the immediate crash, suggesting persistent market stress and altered risk perceptions. While the stability pattern showed signs of recovery, it did not return to pre-crash levels, indicating a fundamental regime shift in how the market approached stablecoin risk.</p>
<p>These findings suggest that monitoring the relative strength of market regimes could provide valuable early warning signals for future stability events. The rapid deterioration of stability patterns, particularly when accompanied by strengthening crisis patterns, might serve as leading indicators of potential stablecoin instability. This framework offers a quantitative approach to stability monitoring that could complement traditional metrics in risk assessment and market surveillance.</p>
</section>
<section id="decision-tree-analysis" class="level3">
<h3 class="anchored" data-anchor-id="decision-tree-analysis">4.4 Decision Tree Analysis</h3>
<p>To better understand the factors that determine stablecoin stability, I employed decision tree analysis for each token. The decision tree analysis revealed a simple yet powerful pattern in stablecoin stability classification. Despite providing the model with a rich set of potential predictors - including volatility, trading volume, network metrics, and temporal features - the trees consistently selected peg deviation as the sole decisive factor. This parsimony in feature selection is particularly noteworthy given that we used unpruned trees, which would have allowed for complex decision paths if they improved classification accuracy.</p>
<div style="display: flex; flex-wrap: wrap; justify-content: center;">
<p><img src="img/tree_USDC.png" width="45%" style="margin: 5px;"> <img src="img/tree_USDT.png" width="45%" style="margin: 5px;"> <img src="img/tree_DAI.png" width="45%" style="margin: 5px;"> <img src="img/tree_PAX.png" width="45%" style="margin: 5px;"> <img src="img/tree_USTC.png" width="45%" style="margin: 5px;"></p>
</div>
<p>Taking USDC’s tree as an illustrative example, we observe a clear three-tier classification structure based on peg deviation thresholds. The primary split occurs at a deviation of 50×10⁻⁶ (0.005%), effectively separating the stable state from potential instability. A secondary threshold at 150×10⁻⁶ (0.015%) further distinguishes between unstable and depegged states. The model achieves perfect classification accuracy (100%) using just these two thresholds, suggesting that peg deviation alone is sufficient for stability assessment.</p>
<p>The tree’s node statistics provide additional insights into the stability distribution: out of 172 total observations, 101 cases maintained strict stability (deviation &lt; 0.005%), while 71 cases showed some form of deviation. Among the deviated cases, 51 were classified as unstable (0.005% &lt; deviation &lt; 0.015%), and 20 as depegged (deviation &gt; 0.015%). This distribution reflects USDC’s generally strong stability, with most deviations being minor and temporary.</p>
<p>Similar patterns emerge across other collateralized stablecoins, with trees showing comparable threshold values and high classification accuracy. This consistency suggests a fundamental property of stablecoin stability - that it can be reliably assessed using peg deviation alone, without requiring complex combinations of market or network metrics. The fact that more sophisticated features did not improve classification accuracy challenges the notion that stablecoin stability requires complex monitoring systems.</p>
<p>This finding has important implications for stablecoin monitoring and risk assessment. While other metrics may provide valuable context, the analysis suggests that simple peg deviation thresholds could serve as reliable primary indicators for stability monitoring. The clear separation between stability states, evidenced by the high classification accuracy using just these thresholds, indicates that stability transitions are more discrete than continuous, supporting the “cliff edge” hypothesis in stablecoin stability dynamics.</p>
<p>However, several limitations of this analysis should be noted. First, the trees’ reliance solely on peg deviation might reflect the lagging nature of other metrics rather than their irrelevance - network and volume indicators could still serve as leading indicators before deviation occurs. Second, the classification boundaries are derived from historical data during a specific market event, and these thresholds might not generalize to different market conditions or future stablecoin designs. Finally, the high accuracy of simple thresholds might indicate that our stability state definitions were themselves too closely tied to deviation values, potentially creating a circular relationship.</p>
</section>
<section id="random-forest-analysis" class="level3">
<h3 class="anchored" data-anchor-id="random-forest-analysis">4.5 Random Forest Analysis</h3>
<p>To complement the decision tree analysis and validate its findings, I implemented separate random forest models for each stablecoin. While individual decision trees provided clear interpretable rules, random forests allow us to assess feature importance more robustly and potentially capture more complex stability patterns for each token individually.</p>
<p><img src="img/forest/importance_DAI.png" class="img-fluid" alt="Feature Importance for DAI"> <img src="img/forest/importance_USDC.png" class="img-fluid" alt="Feature Importance for USDC"> <img src="img/forest/importance_USDT.png" class="img-fluid" alt="Feature Importance for USDT"> <img src="img/forest/importance_PAX.png" class="img-fluid" alt="Feature Importance for PAX"> <img src="img/forest/importance_USTC.png" class="img-fluid" alt="Feature Importance for USTC"></p>
<p>The token-specific random forest analysis reveals both common patterns and unique characteristics:</p>
<p><strong>Higher Dependence on Past Deviations</strong>: USTC’s model heavily weights previous deviations (prev_deviation, peg_deviation, prev_volatility), indicating that its peg stability was highly path-dependent. This suggests that once depegging began, it was strongly reinforced by its prior movements - a characteristic of an unstable feedback loop. In contrast, collateralized stablecoins show more balanced importance across rolling volatility and deviations, suggesting more robust stability mechanisms that don’t solely depend on recent history.</p>
<p><strong>Network Activity Metrics</strong>: Notably, USTC assigns less importance to network-level features (volume, nodes, edges, density), suggesting its collapse was driven more by internal algorithmic instability rather than external transaction activity. This contrasts sharply with USDT, USDC, and DAI, where network-based metrics play a more significant role, indicating that their peg stability is meaningfully influenced by actual transaction behavior and market dynamics.</p>
<p><strong>Deviations vs.&nbsp;Volatility as Indicators</strong>: While USDT and USDC models prioritize volatility as the most important feature, USTC’s model emphasizes deviation-related metrics. This distinction suggests that USTC’s collapse wasn’t triggered by short-term price fluctuations but by sustained and compounding deviation from the peg. The more balanced feature importance distribution in collateralized stablecoins reflects their resilience in responding to various market conditions.</p>
<p><img src="img/forest/predictions_DAI.png" class="img-fluid" alt="Random Forest Predictions for DAI"> <img src="img/forest/predictions_USDC.png" class="img-fluid" alt="Random Forest Predictions for USDC"> <img src="img/forest/predictions_USDT.png" class="img-fluid" alt="Random Forest Predictions for USDT"> <img src="img/forest/predictions_PAX.png" class="img-fluid" alt="Random Forest Predictions for PAX"> <img src="img/forest/predictions_USTC.png" class="img-fluid" alt="Random Forest Predictions for USTC"></p>
<p>The prediction performance metrics reveal interesting variations across tokens. USTC shows the highest R² value (0.913) but also the largest RMSE (0.1308), reflecting its high-variance behavior during the crisis period, as evident in its prediction plot. USDT demonstrates moderate predictive success (R² = 0.723, RMSE = 0.0002), with its predictions closely tracking actual values except during extreme events. In contrast, other collateralized stablecoins show very low R² values (DAI: 0.013, PAX: 0.001, USDC: 0.003) but extremely small RMSEs (0.0003, 0.0018, 0.0001 respectively). These metrics reveal an important insight: while the models struggle to explain the variance in highly stable tokens (low R²), their predictions remain extremely accurate in absolute terms (low RMSE). This pattern suggests that collateralized stablecoins maintain such tight peg control that their minor deviations are essentially random noise, making them statistically unpredictable but operationally reliable.</p>
</section>
<section id="market-regime-clustering-analysis" class="level3">
<h3 class="anchored" data-anchor-id="market-regime-clustering-analysis">4.6 Market Regime Clustering Analysis</h3>
<p>To identify distinct market regimes and understand how different stablecoins behave under varying conditions, we employed an enhanced clustering analysis using a carefully selected set of stability metrics. Principal Component Analysis (PCA) was first applied to reduce dimensionality while preserving key relationships among seven key features: absolute deviation, volatility, deviation change, volatility change, 3-day rolling deviation, 3-day rolling volatility, and deviation-volatility interaction.</p>
<section id="feature-analysis-and-pca-results" class="level4">
<h4 class="anchored" data-anchor-id="feature-analysis-and-pca-results">Feature Analysis and PCA Results</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/improved_clusters/feature_importance.png" class="img-fluid figure-img"></p>
<figcaption>Feature Importance in Clustering</figcaption>
</figure>
</div>
<p>Analysis of feature variances revealed that absolute deviation (0.125) and volatility (0.081) were the most discriminative features, followed by rolling metrics. The interaction between deviation and volatility (0.069) also proved important, suggesting that the relationship between these measures provides additional insight into stability states.</p>
<p><img src="img/improved_clusters/pca_pc1_pc2.png" class="img-fluid" alt="PCA First Two Components"> <img src="img/improved_clusters/pca_pc1_pc3.png" class="img-fluid" alt="PCA Components 1 and 3"></p>
<p>The PCA revealed that approximately 49.4% of the variance was explained by the first principal component, with the second component explaining an additional 23.4%. The visualization of these components shows clear separation between stability states, particularly for USTC compared to other tokens.</p>
</section>
<section id="temporal-distribution" class="level4">
<h4 class="anchored" data-anchor-id="temporal-distribution">Temporal Distribution</h4>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/improved_clusters/temporal_distribution.png" class="img-fluid figure-img"></p>
<figcaption>Temporal Distribution of Clusters</figcaption>
</figure>
</div>
<p>Through silhouette score analysis, we determined that five distinct clusters optimally captured the market regimes (silhouette score = 0.925). The temporal distribution reveals striking differences between USTC and other stablecoins:</p>
<ul>
<li><p>Collateralized stablecoins (DAI, PAX, USDC, USDT) show remarkable consistency, remaining exclusively in Cluster 2 (green) throughout the entire study period. This persistent stability demonstrates the effectiveness of their collateralized design in maintaining peg value across different market conditions.</p></li>
<li><p>USTC exhibits a dramatic regime shift:</p>
<ul>
<li><p>Pre-crash period: Maintains stability in Cluster 2 (green), behaving similarly to collateralized tokens</p></li>
<li><p>Crash period: Brief transition through intermediate states</p></li>
<li><p>Post-crash period: Settles into Cluster 4 (blue), characterized by high deviation with low volatility, indicating a permanent depeg state</p></li>
</ul></li>
</ul>
<p>This temporal evolution provides strong empirical evidence for the “cliff edge” nature of algorithmic stablecoin failures - USTC transitioned abruptly from stable to depegged states with minimal time spent in intermediate clusters, while collateralized tokens maintained consistent stability even during market stress.</p>
</section>
<section id="token-specific-behavior" class="level4">
<h4 class="anchored" data-anchor-id="token-specific-behavior">Token-Specific Behavior</h4>
<p>The token distribution across clusters reveals a stark contrast between algorithmic and collateralized stablecoins. The exact distribution of observations across clusters is shown in Table 1:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Token</th>
<th>Cluster 2</th>
<th>Cluster 1</th>
<th>Cluster 3</th>
<th>Cluster 4</th>
<th>Cluster 5</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DAI</td>
<td>215</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>PAX</td>
<td>215</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>USDC</td>
<td>215</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="even">
<td>USDT</td>
<td>215</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr class="odd">
<td>USTC</td>
<td>40</td>
<td>1</td>
<td>3</td>
<td>170</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>This quantitative breakdown shows: - Collateralized stablecoins (DAI, PAX, USDC, USDT) remained exclusively in Cluster 2 (the stable state) throughout the study period, demonstrating remarkable stability</p>
<ul>
<li><p>USTC showed a more complex pattern:</p>
<ul>
<li><p>40 observations in the stable cluster (2)</p></li>
<li><p>170 observations in high-deviation/low-volatility cluster (4)</p></li>
<li><p>3 observations in the intermediate instability cluster (3)</p></li>
<li><p>Single observations in extreme states (clusters 1 and 5)</p></li>
</ul></li>
</ul>
<p>This distribution quantitatively confirms the “cliff edge” behavior we observed in other analyses - USTC spent most of its time either in stable or severely depegged states, with very few observations in intermediate states.</p>
</section>
<section id="implications-and-limitations" class="level4">
<h4 class="anchored" data-anchor-id="implications-and-limitations">Implications and Limitations</h4>
<p>From the analysis, the clear separation of clusters suggests that market regimes are genuinely distinct states rather than arbitrary divisions of a continuous spectrum. Second, the temporal evolution of clusters could serve as an early warning system - transitions between clusters might be detectable before catastrophic failures occur.</p>
<p>However, several limitations should be noted. The clustering is heavily influenced by the USTC collapse event, and different market stresses might produce different regime patterns. Additionally, the choice of features and number of clusters involves some subjectivity, and alternative specifications might yield different groupings. Despite these limitations, the clustering analysis provides valuable insights into the structural dynamics of stablecoin markets and the differences between stablecoin designs.</p>
</section>
</section>
<section id="lasso-and-ridge-regression-analysis" class="level3">
<h3 class="anchored" data-anchor-id="lasso-and-ridge-regression-analysis">4.7 LASSO and Ridge Regression Analysis</h3>
<p>To identify the most important predictors of stablecoin stability while handling potential multicollinearity, we employed both LASSO (L1) and Ridge (L2) regression for each token. The analysis began with 20 potential features, including lagged variables, rolling metrics, and period indicators, with 5-fold cross-validation for parameter selection.</p>
<section id="token-specific-results" class="level4">
<h4 class="anchored" data-anchor-id="token-specific-results">Token-Specific Results</h4>
<p><strong>USTC (Algorithmic Stablecoin)</strong> showed the most complex predictive patterns. With the highest model performance (LASSO R² = 0.998, RMSE = 0.0181), it identified three key predictors: previous day’s peg deviation (0.620), post-crash indicator (0.346), and crash period indicator (0.182). This strong dependence on historical values and period indicators suggests a path-dependent stability mechanism.</p>
<p><img src="img/lasso_importance_USTC.png" class="img-fluid" alt="LASSO Feature Importance for USTC"> <img src="img/lasso_predictions_USTC.png" class="img-fluid" alt="LASSO Predictions for USTC"></p>
<p><strong>USDT</strong> demonstrated moderate predictability (Ridge R² = 0.579, RMSE = 0.0002), with rolling deviation as its primary predictor. The model captured both stable periods and deviation events effectively.</p>
<p><img src="img/lasso_importance_USDT.png" class="img-fluid" alt="LASSO Feature Importance for USDT"> <img src="img/lasso_predictions_USDT.png" class="img-fluid" alt="LASSO Predictions for USDT"></p>
<p><strong>DAI</strong> showed limited predictability (LASSO R² = 0.051, RMSE = 0.0003), with rolling deviation as the only significant predictor. This simplicity, combined with extremely low RMSE, suggests highly stable behavior with minimal predictable patterns. The feature importance plot for DAI would show only a single feature (rolling deviation), and the prediction plot would appear nearly flat due to the extremely small deviations, making visualization less informative.</p>
<p><strong>USDC</strong> exhibited the most stable behavior (Ridge R² = 0.202, RMSE = 0.0001), with LASSO selecting no predictors. This remarkable result, the inability to find any significant predictors despite the lowest RMSE, indicates near-perfect stability maintenance with deviations that are essentially random noise. With no significant predictors selected by LASSO, the feature importance plot would be empty, and the prediction plot would show an essentially flat line at near-zero deviation.</p>
<p><strong>PAX</strong> showed moderate predictability (Ridge R² = 0.227, RMSE = 0.0015), with rolling deviation as its strongest predictor.</p>
<p><img src="img/lasso_importance_PAX.png" class="img-fluid" alt="LASSO Feature Importance for PAX"> <img src="img/lasso_predictions_PAX.png" class="img-fluid" alt="LASSO Predictions for PAX"></p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="img/lasso_ridge_comparison.png" class="img-fluid figure-img"></p>
<figcaption>LASSO vs Ridge Comparison</figcaption>
</figure>
</div>
<p>The comparison of LASSO and Ridge coefficients reveals distinct stability mechanisms across stablecoin designs. Collateralized stablecoins show consistent patterns: DAI and USDT rely primarily on rolling deviation with moderate feature weights, while USDC’s near-zero coefficients across both models confirm its exceptional stability. PAX exhibits the most distributed feature weights, suggesting more complex stability dynamics despite its collateralized nature.</p>
<p>USTC stands in stark contrast, showing the largest discrepancy between LASSO and Ridge coefficients. Its heavy reliance on lag features and period indicators in both models reinforces our understanding of its path-dependent instability. This fundamental difference in feature importance patterns quantitatively demonstrates the distinction between algorithmic and collateralized stability mechanisms.</p>
<p>The consistency between LASSO and Ridge results for stable tokens, despite their different regularization approaches, suggests these findings are robust to model specification. This comparative analysis provides strong evidence that collateralized stablecoins maintain stability through fundamentally different mechanisms than their algorithmic counterparts.</p>
</section>
<section id="limitations" class="level4">
<h4 class="anchored" data-anchor-id="limitations">Limitations</h4>
<p>The analysis faces several constraints: high correlation between temporal features, limited crisis events in the dataset, potential overfitting in USTC models due to the crash event, and different optimal models across tokens complicating comparison. Despite these limitations, the results provide strong evidence for fundamental differences between algorithmic and collateralized stability mechanisms.</p>
</section>
</section>
<section id="model-performance-comparison" class="level3">
<h3 class="anchored" data-anchor-id="model-performance-comparison">4.8 Model Performance Comparison</h3>
<p>To evaluate the relative strengths of our different modeling approaches, we compared performance metrics across all models and tokens. This comparison provides insights into which approaches are most effective for stability prediction and classification.</p>
<section id="classification-vs.-regression-performance" class="level4">
<h4 class="anchored" data-anchor-id="classification-vs.-regression-performance">Classification vs.&nbsp;Regression Performance</h4>
<p>Our analysis revealed a clear distinction between classification and regression performance across stablecoin types. Decision trees achieved near-perfect classification accuracy (97-100%) across all tokens, confirming that stability states are clearly separable into distinct regimes. This exceptional classification performance was consistent across both collateralized and algorithmic stablecoins, suggesting that the boundary between stability and instability is well-defined regardless of the underlying stability mechanism.</p>
<p>In contrast, regression models (Random Forests, LASSO/Ridge) showed highly variable R² values (0.001-0.998), with a striking pattern: higher predictability for unstable tokens and lower predictability for stable ones. This pattern was consistent across all regression models, suggesting it reflects an inherent property of stablecoin stability rather than a model-specific limitation.</p>
</section>
<section id="token-specific-patterns" class="level4">
<h4 class="anchored" data-anchor-id="token-specific-patterns">Token-Specific Patterns</h4>
<p>USTC (algorithmic) demonstrated the highest predictability in regression models, with extraordinary R² values (LASSO: 0.998, Ridge: 0.996, Random Forest: 0.913). However, it showed slightly lower classification accuracy (97%) compared to collateralized tokens. This suggests that while USTC’s deviations follow highly predictable patterns, its stability state boundaries are somewhat less distinct.</p>
<p>USDT (collateralized) exhibited moderate predictability across regression models (Random Forest: 0.723, Ridge: 0.579, LASSO: 0.199), indicating more complex but still somewhat predictable stability dynamics. Its high classification accuracy (99%) confirms clear stability state boundaries.</p>
<p>USDC, DAI, and PAX (all collateralized) showed remarkably low regression R² values (0.001-0.202) despite having perfect or near-perfect classification accuracy (98-100%). This striking contrast between classification and regression performance for these tokens reveals a fundamental insight: well-functioning stablecoins maintain such tight peg control that their minor deviations are essentially random noise, making them statistically unpredictable despite being operationally reliable.</p>
</section>
<section id="model-specific-insights" class="level4">
<h4 class="anchored" data-anchor-id="model-specific-insights">Model-Specific Insights</h4>
<p><strong>Decision Trees</strong> demonstrated exceptional classification performance across all tokens, with accuracy ranging from 97% (USTC) to 100% (USDC). Their primary strength lies in identifying clear threshold values that separate stability states, making them highly interpretable and valuable for early warning systems. The trees consistently identified peg deviation thresholds around 0.01-0.03 as critical decision boundaries, with secondary splits based on volatility and network metrics. However, they cannot provide quantitative predictions of deviation magnitude, limiting their utility for continuous monitoring.</p>
<p><strong>Random Forests</strong> showed strong predictive performance for unstable tokens (USTC: R² = 0.913) and moderate performance for USDT (R² = 0.723), but poor performance for highly stable tokens (USDC: R² = 0.003, DAI: R² = 0.013, PAX: R² = 0.001). Feature importance analysis revealed that random forests relied primarily on lagged deviation and rolling metrics for USTC, while network metrics played a more significant role for USDT. This pattern suggests that random forests excel at capturing complex non-linear relationships in tokens with discernible patterns of instability but struggle with the essentially random minor fluctuations of well-functioning stablecoins.</p>
<p><strong>LASSO Regression</strong> achieved exceptional predictive performance for USTC (R² = 0.998, RMSE = 0.0181) while performing poorly for stable tokens. Its automatic feature selection through L1 regularization identified key predictors: previous day’s deviation (0.620), post-crash indicator (0.346), and crash period indicator (0.182) for USTC, highlighting the path-dependent nature of algorithmic stablecoin instability. For USDT, LASSO selected rolling deviation (0.40) and volatility (0.30) as primary predictors, with network metrics playing a secondary role. The stark difference in selected features between USTC and collateralized tokens provides quantitative evidence for fundamentally different stability mechanisms.</p>
<p><strong>Ridge Regression</strong> showed strong performance for USTC (R² = 0.996) and moderate performance for USDT (R² = 0.579). By retaining all features with appropriate weighting through L2 regularization, ridge regression provided a more comprehensive view of stability drivers while still handling multicollinearity effectively. The coefficient patterns closely mirrored those of LASSO but with less extreme feature selection, confirming the robustness of our findings across different regularization approaches.</p>
</section>
<section id="the-stability-paradox" class="level4">
<h4 class="anchored" data-anchor-id="the-stability-paradox">The Stability Paradox</h4>
<p>The different models revealed an important paradox in stablecoin stability modeling: the most stable tokens (like USDC and DAI) show the poorest regression performance (low R²) despite having the best stability outcomes (low RMSE and high classification accuracy). This suggests that well-functioning stablecoins maintain such tight peg control that their minor deviations are essentially random and thus unpredictable, while unstable tokens show higher predictability precisely because their deviations follow discernible patterns.</p>
<p>This non-linear relationship between predictability and stability reinforces our understanding that stablecoin stability is fundamentally a classification problem with distinct states rather than a continuous spectrum. Tokens cluster either in the high-R²/high-RMSE region (USTC) or the low-R²/low-RMSE region (collateralized stablecoins), with very few observations in intermediate states.</p>
</section>
<section id="practical-implications" class="level4">
<h4 class="anchored" data-anchor-id="practical-implications">Practical Implications</h4>
<p>The practical implication is that different modeling approaches are appropriate for different stability monitoring tasks:</p>
<p>Classification models (decision trees) are ideal for stability state monitoring. Regression models (random forests, LASSO/Ridge) are better suited for quantitative deviation prediction. Feature importance analysis across models provides complementary insights into stability mechanisms</p>
<p>For early warning systems, a hybrid approach combining decision trees for state classification with random forests for quantitative prediction offers the best balance of interpretability and predictive power. The complementary nature of these models suggests that a multi-model approach is optimal for comprehensive stability analysis, with each model contributing unique insights into different aspects of stablecoin behavior.</p>
<p>These findings reinforce our understanding that stablecoin stability is fundamentally a classification problem with distinct states rather than a continuous spectrum, supporting the “cliff edge” hypothesis observed throughout our analyses.</p>
</section>
</section>
</section>
<section id="conclusion-and-future-directions" class="level2">
<h2 class="anchored" data-anchor-id="conclusion-and-future-directions">5. Conclusion and Future Directions</h2>
<section id="key-findings" class="level3">
<h3 class="anchored" data-anchor-id="key-findings">5.1 Key Findings</h3>
<p>The comprehensive analysis of stablecoin stability dynamics revealed several critical insights:</p>
<ol type="1">
<li><p><strong>Fundamental Design Differences</strong>: Collateralized stablecoins (USDT, USDC, DAI, PAX) maintained remarkable stability throughout the study period, while algorithmic USTC exhibited catastrophic failure with no recovery, confirming the structural vulnerability of purely algorithmic designs.</p></li>
<li><p><strong>“Cliff Edge” Phenomenon</strong>: Stablecoin stability transitions are not gradual but exhibit abrupt “cliff edge” behavior. USTC maintained apparent stability until just before its catastrophic failure, with minimal time spent in intermediate stability states.</p></li>
<li><p><strong>Stability Paradox</strong>: The most stable tokens showed the poorest regression performance (low R²) despite having the best stability outcomes (low RMSE), suggesting well-functioning stablecoins maintain such tight peg control that their minor deviations are essentially random noise.</p></li>
<li><p><strong>Distinct Stability Mechanisms</strong>: USTC showed strong path dependence with heavy reliance on previous deviations, suggesting a self-reinforcing instability mechanism. Collateralized tokens demonstrated more balanced feature importance with significant influence from network metrics.</p></li>
<li><p><strong>Classification Superiority</strong>: Decision trees achieved near-perfect classification accuracy (97-100%) across all tokens, while regression models showed highly variable performance, suggesting stability state classification is more reliable than continuous deviation prediction.</p></li>
<li><p><strong>Limited Early Warning Signals</strong>: Traditional stability metrics provided minimal advance warning of USTC’s collapse, with models underestimating the severity and speed of the failure.</p></li>
<li><p><strong>Contained Contagion</strong>: Despite USTC’s collapse, other stablecoins showed remarkable resilience with minimal contagion effects, suggesting effective market compartmentalization.</p></li>
</ol>
</section>
<section id="implications" class="level3">
<h3 class="anchored" data-anchor-id="implications">5.2 Implications</h3>
<ol type="1">
<li><p><strong>Design Considerations</strong>: Effective stablecoin designs should incorporate robust external collateral mechanisms rather than relying solely on algorithmic adjustments.</p></li>
<li><p><strong>Monitoring Frameworks</strong>: Stability monitoring should focus on identifying critical thresholds rather than tracking gradual changes, with decision tree models potentially providing more actionable insights.</p></li>
<li><p><strong>Early Warning Systems</strong>: Monitoring systems should incorporate diverse indicators beyond traditional stability metrics, including transaction pattern analysis and market regime identification.</p></li>
<li><p><strong>Regulatory Approaches</strong>: Regulatory frameworks should distinguish between algorithmic and collateralized designs, with potentially stricter requirements for algorithmic tokens given their demonstrated vulnerability.</p></li>
<li><p><strong>Risk Communication</strong>: Stakeholders should be educated about the potential for sudden, catastrophic failures rather than gradual deterioration, particularly for algorithmic designs.</p></li>
</ol>
</section>
<section id="future-research" class="level3">
<h3 class="anchored" data-anchor-id="future-research">5.3 Future Research</h3>
<p>Future research should address current limitations through:</p>
<ol type="1">
<li><p><strong>Expanded Analysis</strong>: Include more tokens and multiple stress events across different market cycles.</p></li>
<li><p><strong>Network Contagion Modeling</strong>: Develop sophisticated models to understand how stability issues propagate through the cryptocurrency ecosystem.</p></li>
<li><p><strong>Real-Time Monitoring</strong>: Develop and test monitoring frameworks integrating classification models with transaction pattern analysis.</p></li>
<li><p><strong>Cross-Chain Dynamics</strong>: Extend analysis to stablecoins operating across multiple blockchains.</p></li>
<li><p><strong>Market Microstructure</strong>: Analyze liquidity provision, market making, and arbitrage activities during stability events.</p></li>
</ol>
<p>This research provides a framework for understanding stablecoin stability dynamics and offers valuable insights for designers, users, and regulators. The multi-model approach demonstrates the value of combining different analytical perspectives when studying complex financial systems during periods of market stress.</p>
</section>
</section>
<section id="appendix" class="level2">
<h2 class="anchored" data-anchor-id="appendix">Appendix</h2>
<section id="a.-key-code-samples" class="level3">
<h3 class="anchored" data-anchor-id="a.-key-code-samples">A. Key Code Samples</h3>
<section id="a.1-decision-tree-implementation" class="level4">
<h4 class="anchored" data-anchor-id="a.1-decision-tree-implementation">A.1 Decision Tree Implementation</h4>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to build and evaluate decision trees for each token</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>build_stability_trees <span class="ot">&lt;-</span> <span class="cf">function</span>(stability_data) {</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Required packages</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">require</span>(rpart)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">require</span>(rpart.plot)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Initialize results list</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  tree_results <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># For each token</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (token_name <span class="cf">in</span> <span class="fu">unique</span>(stability_data<span class="sc">$</span>token)) {</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filter data for this token</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    token_data <span class="ot">&lt;-</span> stability_data <span class="sc">%&gt;%</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">filter</span>(token <span class="sc">==</span> token_name) <span class="sc">%&gt;%</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Create stability class based on peg deviation</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">mutate</span>(<span class="at">stability_class =</span> <span class="fu">case_when</span>(</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="fu">abs</span>(peg_deviation) <span class="sc">&lt;</span> <span class="fl">0.005</span> <span class="sc">~</span> <span class="st">"stable"</span>,</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="fu">abs</span>(peg_deviation) <span class="sc">&lt;</span> <span class="fl">0.05</span> <span class="sc">~</span> <span class="st">"unstable"</span>,</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="cn">TRUE</span> <span class="sc">~</span> <span class="st">"depegged"</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>      )) <span class="sc">%&gt;%</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Convert to factor with ordered levels</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>      <span class="fu">mutate</span>(<span class="at">stability_class =</span> <span class="fu">factor</span>(stability_class, </span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"stable"</span>, <span class="st">"unstable"</span>, <span class="st">"depegged"</span>),</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">ordered =</span> <span class="cn">TRUE</span>))</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build decision tree</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    tree_model <span class="ot">&lt;-</span> <span class="fu">rpart</span>(stability_class <span class="sc">~</span> peg_deviation <span class="sc">+</span> volatility <span class="sc">+</span> volume <span class="sc">+</span> </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>                        nodes <span class="sc">+</span> edges <span class="sc">+</span> density <span class="sc">+</span> modularity <span class="sc">+</span> reciprocity,</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>                        <span class="at">data =</span> token_data,</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>                        <span class="at">method =</span> <span class="st">"class"</span>,</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>                        <span class="at">control =</span> <span class="fu">rpart.control</span>(<span class="at">cp =</span> <span class="fl">0.001</span>, <span class="at">minsplit =</span> <span class="dv">5</span>))</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Make predictions</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>    predictions <span class="ot">&lt;-</span> <span class="fu">predict</span>(tree_model, token_data, <span class="at">type =</span> <span class="st">"class"</span>)</span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate accuracy</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    accuracy <span class="ot">&lt;-</span> <span class="fu">sum</span>(predictions <span class="sc">==</span> token_data<span class="sc">$</span>stability_class) <span class="sc">/</span> <span class="fu">nrow</span>(token_data)</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate AUC for binary classification (stable vs not stable)</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>    binary_actual <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(token_data<span class="sc">$</span>stability_class <span class="sc">==</span> <span class="st">"stable"</span>, <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>    binary_pred <span class="ot">&lt;-</span> <span class="fu">predict</span>(tree_model, token_data)[, <span class="st">"stable"</span>]</span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    auc <span class="ot">&lt;-</span> <span class="fu">tryCatch</span>({</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>      roc_obj <span class="ot">&lt;-</span> <span class="fu">roc</span>(binary_actual, binary_pred)</span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>      <span class="fu">auc</span>(roc_obj)</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>    }, <span class="at">error =</span> <span class="cf">function</span>(e) {</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a>      <span class="cn">NA</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store results</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>    tree_results[[token_name]] <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>      <span class="at">model =</span> tree_model,</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>      <span class="at">predictions =</span> predictions,</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>      <span class="at">accuracy =</span> accuracy,</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>      <span class="at">auc =</span> auc,</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>      <span class="at">confusion_matrix =</span> <span class="fu">table</span>(<span class="at">Actual =</span> token_data<span class="sc">$</span>stability_class, </span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>                              <span class="at">Predicted =</span> predictions)</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create and save tree visualization</span></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>    <span class="fu">png</span>(<span class="fu">paste0</span>(<span class="st">"img/tree_"</span>, token_name, <span class="st">".png"</span>), <span class="at">width =</span> <span class="dv">800</span>, <span class="at">height =</span> <span class="dv">600</span>)</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rpart.plot</span>(tree_model, </span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>               <span class="at">main =</span> <span class="fu">paste</span>(<span class="st">"Decision Tree for"</span>, token_name),</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>               <span class="at">extra =</span> <span class="dv">106</span>,  <span class="co"># Show class distributions</span></span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>               <span class="at">box.palette =</span> <span class="st">"RdYlGn"</span>,  <span class="co"># Red for depegged, green for stable</span></span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>               <span class="at">shadow.col =</span> <span class="st">"gray"</span>)</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>    <span class="fu">dev.off</span>()</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(tree_results)</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="a.2-random-forest-implementation" class="level4">
<h4 class="anchored" data-anchor-id="a.2-random-forest-implementation">A.2 Random Forest Implementation</h4>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to build and evaluate random forests for regression</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>build_stability_forest <span class="ot">&lt;-</span> <span class="cf">function</span>(stability_data) {</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Required packages</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">require</span>(randomForest)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">require</span>(ggplot2)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Initialize results list</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  forest_results <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># For each token</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (token_name <span class="cf">in</span> <span class="fu">unique</span>(stability_data<span class="sc">$</span>token)) {</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filter data for this token</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    token_data <span class="ot">&lt;-</span> stability_data <span class="sc">%&gt;%</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">filter</span>(token <span class="sc">==</span> token_name) <span class="sc">%&gt;%</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Create lagged features</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">mutate</span>(<span class="at">prev_deviation =</span> <span class="fu">lag</span>(peg_deviation, <span class="dv">1</span>),</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>             <span class="at">prev_volatility =</span> <span class="fu">lag</span>(volatility, <span class="dv">1</span>)) <span class="sc">%&gt;%</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove rows with NA values</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>      <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(prev_deviation), <span class="sc">!</span><span class="fu">is.na</span>(prev_volatility))</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Split into training and test sets (80/20)</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set.seed</span>(<span class="dv">123</span>)  <span class="co"># For reproducibility</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    train_idx <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(token_data), <span class="fl">0.8</span> <span class="sc">*</span> <span class="fu">nrow</span>(token_data))</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    train_data <span class="ot">&lt;-</span> token_data[train_idx, ]</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    test_data <span class="ot">&lt;-</span> token_data[<span class="sc">-</span>train_idx, ]</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build random forest model</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    rf_model <span class="ot">&lt;-</span> <span class="fu">randomForest</span>(</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>      peg_deviation <span class="sc">~</span> prev_deviation <span class="sc">+</span> prev_volatility <span class="sc">+</span> volatility <span class="sc">+</span> </span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                     volume <span class="sc">+</span> nodes <span class="sc">+</span> edges <span class="sc">+</span> density <span class="sc">+</span> modularity <span class="sc">+</span> </span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                     rolling_dev <span class="sc">+</span> is_weekend <span class="sc">+</span> period_indicator,</span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>      <span class="at">data =</span> train_data,</span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>      <span class="at">ntree =</span> <span class="dv">500</span>,</span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>      <span class="at">importance =</span> <span class="cn">TRUE</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Make predictions on test set</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    predictions <span class="ot">&lt;-</span> <span class="fu">predict</span>(rf_model, test_data)</span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate performance metrics</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>    rmse <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">mean</span>((predictions <span class="sc">-</span> test_data<span class="sc">$</span>peg_deviation)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>    r_squared <span class="ot">&lt;-</span> <span class="fu">cor</span>(predictions, test_data<span class="sc">$</span>peg_deviation)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract feature importance</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    importance_df <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">importance</span>(rf_model)) <span class="sc">%&gt;%</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>      <span class="fu">rownames_to_column</span>(<span class="st">"feature"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>      <span class="fu">arrange</span>(<span class="fu">desc</span>(IncNodePurity)) <span class="sc">%&gt;%</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>      <span class="fu">mutate</span>(<span class="at">importance =</span> IncNodePurity <span class="sc">/</span> <span class="fu">sum</span>(IncNodePurity))</span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create importance plot</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>    p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="fu">head</span>(importance_df, <span class="dv">10</span>), </span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>                <span class="fu">aes</span>(<span class="at">x =</span> <span class="fu">reorder</span>(feature, importance), <span class="at">y =</span> importance)) <span class="sc">+</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_bar</span>(<span class="at">stat =</span> <span class="st">"identity"</span>, <span class="at">fill =</span> <span class="st">"steelblue"</span>) <span class="sc">+</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>      <span class="fu">coord_flip</span>() <span class="sc">+</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>      <span class="fu">labs</span>(<span class="at">title =</span> <span class="fu">paste</span>(<span class="st">"Feature Importance for"</span>, token_name),</span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a>           <span class="at">x =</span> <span class="st">"Feature"</span>,</span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>           <span class="at">y =</span> <span class="st">"Importance"</span>) <span class="sc">+</span></span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_minimal</span>()</span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save importance plot</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ggsave</span>(<span class="fu">paste0</span>(<span class="st">"img/forest/importance_"</span>, token_name, <span class="st">".png"</span>), p1, </span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>           <span class="at">width =</span> <span class="dv">8</span>, <span class="at">height =</span> <span class="dv">6</span>)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create prediction plot</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>    prediction_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>      <span class="at">date =</span> test_data<span class="sc">$</span>date,</span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a>      <span class="at">actual =</span> test_data<span class="sc">$</span>peg_deviation,</span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>      <span class="at">predicted =</span> predictions</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>    ) <span class="sc">%&gt;%</span></span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>      <span class="fu">arrange</span>(date)</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>    p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(prediction_df, <span class="fu">aes</span>(<span class="at">x =</span> date)) <span class="sc">+</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">y =</span> actual, <span class="at">color =</span> <span class="st">"Actual"</span>), <span class="at">size =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">y =</span> predicted, <span class="at">color =</span> <span class="st">"Predicted"</span>), </span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>                <span class="at">linetype =</span> <span class="st">"dashed"</span>, <span class="at">size =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a>      <span class="fu">scale_color_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">"Actual"</span> <span class="ot">=</span> <span class="st">"black"</span>, <span class="st">"Predicted"</span> <span class="ot">=</span> <span class="st">"blue"</span>)) <span class="sc">+</span></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a>      <span class="fu">labs</span>(<span class="at">title =</span> <span class="fu">paste</span>(<span class="st">"Random Forest Predictions for"</span>, token_name),</span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>           <span class="at">x =</span> <span class="st">"Date"</span>,</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>           <span class="at">y =</span> <span class="st">"Peg Deviation"</span>,</span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a>           <span class="at">color =</span> <span class="st">""</span>) <span class="sc">+</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"bottom"</span>)</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save prediction plot</span></span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ggsave</span>(<span class="fu">paste0</span>(<span class="st">"img/forest/predictions_"</span>, token_name, <span class="st">".png"</span>), p2, </span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a>           <span class="at">width =</span> <span class="dv">10</span>, <span class="at">height =</span> <span class="dv">6</span>)</span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store results</span></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a>    forest_results[[token_name]] <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a>      <span class="at">model =</span> rf_model,</span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a>      <span class="at">predictions =</span> prediction_df,</span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>      <span class="at">rmse =</span> rmse,</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>      <span class="at">r_squared =</span> r_squared,</span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>      <span class="at">importance =</span> importance_df</span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(forest_results)</span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="a.3-lassoridge-regression-implementation" class="level4">
<h4 class="anchored" data-anchor-id="a.3-lassoridge-regression-implementation">A.3 LASSO/Ridge Regression Implementation</h4>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to build and evaluate LASSO and Ridge regression models</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>build_stability_models <span class="ot">&lt;-</span> <span class="cf">function</span>(stability_data) {</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Required packages</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">require</span>(glmnet)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">require</span>(ggplot2)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Initialize results list</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  model_results <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># For each token</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (token_name <span class="cf">in</span> <span class="fu">unique</span>(stability_data<span class="sc">$</span>token)) {</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Filter data for this token</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    token_data <span class="ot">&lt;-</span> stability_data <span class="sc">%&gt;%</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>      <span class="fu">filter</span>(token <span class="sc">==</span> token_name) <span class="sc">%&gt;%</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Create lagged features</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>      <span class="fu">mutate</span>(</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="at">prev_deviation =</span> <span class="fu">lag</span>(peg_deviation, <span class="dv">1</span>),</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="at">prev_volatility =</span> <span class="fu">lag</span>(volatility, <span class="dv">1</span>),</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="at">is_crash_period =</span> <span class="fu">ifelse</span>(date <span class="sc">&gt;=</span> <span class="fu">as.Date</span>(<span class="st">"2022-05-08"</span>) <span class="sc">&amp;</span> </span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                                date <span class="sc">&lt;=</span> <span class="fu">as.Date</span>(<span class="st">"2022-05-15"</span>), <span class="dv">1</span>, <span class="dv">0</span>),</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="at">is_post_crash =</span> <span class="fu">ifelse</span>(date <span class="sc">&gt;</span> <span class="fu">as.Date</span>(<span class="st">"2022-05-15"</span>), <span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>      ) <span class="sc">%&gt;%</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Remove rows with NA values</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>      <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(prev_deviation), <span class="sc">!</span><span class="fu">is.na</span>(prev_volatility))</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Prepare model matrix</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    x_vars <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="sc">~</span> prev_deviation <span class="sc">+</span> prev_volatility <span class="sc">+</span> volatility <span class="sc">+</span> </span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>                           volume <span class="sc">+</span> nodes <span class="sc">+</span> edges <span class="sc">+</span> density <span class="sc">+</span> modularity <span class="sc">+</span> </span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>                           rolling_dev <span class="sc">+</span> is_weekend <span class="sc">+</span> is_crash_period <span class="sc">+</span> </span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>                           is_post_crash <span class="sc">-</span> <span class="dv">1</span>, <span class="at">data =</span> token_data)</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    y_var <span class="ot">&lt;-</span> token_data<span class="sc">$</span>peg_deviation</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Split into training and test sets (80/20)</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set.seed</span>(<span class="dv">123</span>)  <span class="co"># For reproducibility</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    train_idx <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(token_data), <span class="fl">0.8</span> <span class="sc">*</span> <span class="fu">nrow</span>(token_data))</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    x_train <span class="ot">&lt;-</span> x_vars[train_idx, ]</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    y_train <span class="ot">&lt;-</span> y_var[train_idx]</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    x_test <span class="ot">&lt;-</span> x_vars[<span class="sc">-</span>train_idx, ]</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    y_test <span class="ot">&lt;-</span> y_var[<span class="sc">-</span>train_idx]</span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find optimal lambda using cross-validation</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    cv_lasso <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(x_train, y_train, <span class="at">alpha =</span> <span class="dv">1</span>, <span class="at">nfolds =</span> <span class="dv">5</span>)</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    cv_ridge <span class="ot">&lt;-</span> <span class="fu">cv.glmnet</span>(x_train, y_train, <span class="at">alpha =</span> <span class="dv">0</span>, <span class="at">nfolds =</span> <span class="dv">5</span>)</span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build LASSO model with optimal lambda</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    lasso_model <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(x_train, y_train, <span class="at">alpha =</span> <span class="dv">1</span>, </span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>                         <span class="at">lambda =</span> cv_lasso<span class="sc">$</span>lambda.min)</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build Ridge model with optimal lambda</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>    ridge_model <span class="ot">&lt;-</span> <span class="fu">glmnet</span>(x_train, y_train, <span class="at">alpha =</span> <span class="dv">0</span>, </span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>                         <span class="at">lambda =</span> cv_ridge<span class="sc">$</span>lambda.min)</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Make predictions</span></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a>    lasso_preds <span class="ot">&lt;-</span> <span class="fu">predict</span>(lasso_model, x_test)</span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    ridge_preds <span class="ot">&lt;-</span> <span class="fu">predict</span>(ridge_model, x_test)</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate performance metrics</span></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>    lasso_rmse <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">mean</span>((lasso_preds <span class="sc">-</span> y_test)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>    lasso_r2 <span class="ot">&lt;-</span> <span class="fu">cor</span>(lasso_preds, y_test)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>    ridge_rmse <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(<span class="fu">mean</span>((ridge_preds <span class="sc">-</span> y_test)<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a>    ridge_r2 <span class="ot">&lt;-</span> <span class="fu">cor</span>(ridge_preds, y_test)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract coefficients</span></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>    lasso_coef <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">as.matrix</span>(<span class="fu">coef</span>(lasso_model))) <span class="sc">%&gt;%</span></span>
<span id="cb3-65"><a href="#cb3-65" aria-hidden="true" tabindex="-1"></a>      <span class="fu">rownames_to_column</span>(<span class="st">"feature"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-66"><a href="#cb3-66" aria-hidden="true" tabindex="-1"></a>      <span class="fu">rename</span>(<span class="at">coefficient =</span> s0) <span class="sc">%&gt;%</span></span>
<span id="cb3-67"><a href="#cb3-67" aria-hidden="true" tabindex="-1"></a>      <span class="fu">filter</span>(coefficient <span class="sc">!=</span> <span class="dv">0</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-68"><a href="#cb3-68" aria-hidden="true" tabindex="-1"></a>      <span class="fu">arrange</span>(<span class="fu">desc</span>(<span class="fu">abs</span>(coefficient)))</span>
<span id="cb3-69"><a href="#cb3-69" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-70"><a href="#cb3-70" aria-hidden="true" tabindex="-1"></a>    ridge_coef <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(<span class="fu">as.matrix</span>(<span class="fu">coef</span>(ridge_model))) <span class="sc">%&gt;%</span></span>
<span id="cb3-71"><a href="#cb3-71" aria-hidden="true" tabindex="-1"></a>      <span class="fu">rownames_to_column</span>(<span class="st">"feature"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-72"><a href="#cb3-72" aria-hidden="true" tabindex="-1"></a>      <span class="fu">rename</span>(<span class="at">coefficient =</span> s0) <span class="sc">%&gt;%</span></span>
<span id="cb3-73"><a href="#cb3-73" aria-hidden="true" tabindex="-1"></a>      <span class="fu">filter</span>(coefficient <span class="sc">!=</span> <span class="dv">0</span>) <span class="sc">%&gt;%</span></span>
<span id="cb3-74"><a href="#cb3-74" aria-hidden="true" tabindex="-1"></a>      <span class="fu">arrange</span>(<span class="fu">desc</span>(<span class="fu">abs</span>(coefficient)))</span>
<span id="cb3-75"><a href="#cb3-75" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-76"><a href="#cb3-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create coefficient plot for LASSO</span></span>
<span id="cb3-77"><a href="#cb3-77" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">nrow</span>(lasso_coef) <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb3-78"><a href="#cb3-78" aria-hidden="true" tabindex="-1"></a>      p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(lasso_coef, </span>
<span id="cb3-79"><a href="#cb3-79" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">aes</span>(<span class="at">x =</span> <span class="fu">reorder</span>(feature, <span class="fu">abs</span>(coefficient)), </span>
<span id="cb3-80"><a href="#cb3-80" aria-hidden="true" tabindex="-1"></a>                      <span class="at">y =</span> <span class="fu">abs</span>(coefficient))) <span class="sc">+</span></span>
<span id="cb3-81"><a href="#cb3-81" aria-hidden="true" tabindex="-1"></a>        <span class="fu">geom_bar</span>(<span class="at">stat =</span> <span class="st">"identity"</span>, <span class="at">fill =</span> <span class="st">"darkred"</span>) <span class="sc">+</span></span>
<span id="cb3-82"><a href="#cb3-82" aria-hidden="true" tabindex="-1"></a>        <span class="fu">coord_flip</span>() <span class="sc">+</span></span>
<span id="cb3-83"><a href="#cb3-83" aria-hidden="true" tabindex="-1"></a>        <span class="fu">labs</span>(<span class="at">title =</span> <span class="fu">paste</span>(<span class="st">"LASSO Feature Importance for"</span>, token_name),</span>
<span id="cb3-84"><a href="#cb3-84" aria-hidden="true" tabindex="-1"></a>             <span class="at">x =</span> <span class="st">"Feature"</span>,</span>
<span id="cb3-85"><a href="#cb3-85" aria-hidden="true" tabindex="-1"></a>             <span class="at">y =</span> <span class="st">"Absolute Coefficient"</span>) <span class="sc">+</span></span>
<span id="cb3-86"><a href="#cb3-86" aria-hidden="true" tabindex="-1"></a>        <span class="fu">theme_minimal</span>()</span>
<span id="cb3-87"><a href="#cb3-87" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb3-88"><a href="#cb3-88" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Save importance plot</span></span>
<span id="cb3-89"><a href="#cb3-89" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ggsave</span>(<span class="fu">paste0</span>(<span class="st">"img/lasso_importance_"</span>, token_name, <span class="st">".png"</span>), p1, </span>
<span id="cb3-90"><a href="#cb3-90" aria-hidden="true" tabindex="-1"></a>             <span class="at">width =</span> <span class="dv">8</span>, <span class="at">height =</span> <span class="dv">6</span>)</span>
<span id="cb3-91"><a href="#cb3-91" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb3-92"><a href="#cb3-92" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-93"><a href="#cb3-93" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create prediction plot</span></span>
<span id="cb3-94"><a href="#cb3-94" aria-hidden="true" tabindex="-1"></a>    test_dates <span class="ot">&lt;-</span> token_data<span class="sc">$</span>date[<span class="sc">-</span>train_idx]</span>
<span id="cb3-95"><a href="#cb3-95" aria-hidden="true" tabindex="-1"></a>    prediction_df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb3-96"><a href="#cb3-96" aria-hidden="true" tabindex="-1"></a>      <span class="at">date =</span> test_dates,</span>
<span id="cb3-97"><a href="#cb3-97" aria-hidden="true" tabindex="-1"></a>      <span class="at">actual =</span> y_test,</span>
<span id="cb3-98"><a href="#cb3-98" aria-hidden="true" tabindex="-1"></a>      <span class="at">predicted =</span> <span class="fu">as.vector</span>(lasso_preds)</span>
<span id="cb3-99"><a href="#cb3-99" aria-hidden="true" tabindex="-1"></a>    ) <span class="sc">%&gt;%</span></span>
<span id="cb3-100"><a href="#cb3-100" aria-hidden="true" tabindex="-1"></a>      <span class="fu">arrange</span>(date)</span>
<span id="cb3-101"><a href="#cb3-101" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-102"><a href="#cb3-102" aria-hidden="true" tabindex="-1"></a>    p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(prediction_df, <span class="fu">aes</span>(<span class="at">x =</span> date)) <span class="sc">+</span></span>
<span id="cb3-103"><a href="#cb3-103" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">y =</span> actual, <span class="at">color =</span> <span class="st">"Actual"</span>), <span class="at">size =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb3-104"><a href="#cb3-104" aria-hidden="true" tabindex="-1"></a>      <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">y =</span> predicted, <span class="at">color =</span> <span class="st">"Predicted"</span>), </span>
<span id="cb3-105"><a href="#cb3-105" aria-hidden="true" tabindex="-1"></a>                <span class="at">linetype =</span> <span class="st">"dashed"</span>, <span class="at">size =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb3-106"><a href="#cb3-106" aria-hidden="true" tabindex="-1"></a>      <span class="fu">scale_color_manual</span>(<span class="at">values =</span> <span class="fu">c</span>(<span class="st">"Actual"</span> <span class="ot">=</span> <span class="st">"black"</span>, <span class="st">"Predicted"</span> <span class="ot">=</span> <span class="st">"red"</span>)) <span class="sc">+</span></span>
<span id="cb3-107"><a href="#cb3-107" aria-hidden="true" tabindex="-1"></a>      <span class="fu">labs</span>(<span class="at">title =</span> <span class="fu">paste</span>(<span class="st">"LASSO Predictions for"</span>, token_name),</span>
<span id="cb3-108"><a href="#cb3-108" aria-hidden="true" tabindex="-1"></a>           <span class="at">x =</span> <span class="st">"Date"</span>,</span>
<span id="cb3-109"><a href="#cb3-109" aria-hidden="true" tabindex="-1"></a>           <span class="at">y =</span> <span class="st">"Peg Deviation"</span>,</span>
<span id="cb3-110"><a href="#cb3-110" aria-hidden="true" tabindex="-1"></a>           <span class="at">color =</span> <span class="st">""</span>) <span class="sc">+</span></span>
<span id="cb3-111"><a href="#cb3-111" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb3-112"><a href="#cb3-112" aria-hidden="true" tabindex="-1"></a>      <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"bottom"</span>)</span>
<span id="cb3-113"><a href="#cb3-113" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-114"><a href="#cb3-114" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Save prediction plot</span></span>
<span id="cb3-115"><a href="#cb3-115" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ggsave</span>(<span class="fu">paste0</span>(<span class="st">"img/lasso_predictions_"</span>, token_name, <span class="st">".png"</span>), p2, </span>
<span id="cb3-116"><a href="#cb3-116" aria-hidden="true" tabindex="-1"></a>           <span class="at">width =</span> <span class="dv">10</span>, <span class="at">height =</span> <span class="dv">6</span>)</span>
<span id="cb3-117"><a href="#cb3-117" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-118"><a href="#cb3-118" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Store results</span></span>
<span id="cb3-119"><a href="#cb3-119" aria-hidden="true" tabindex="-1"></a>    model_results[[token_name]] <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb3-120"><a href="#cb3-120" aria-hidden="true" tabindex="-1"></a>      <span class="at">lasso_model =</span> lasso_model,</span>
<span id="cb3-121"><a href="#cb3-121" aria-hidden="true" tabindex="-1"></a>      <span class="at">ridge_model =</span> ridge_model,</span>
<span id="cb3-122"><a href="#cb3-122" aria-hidden="true" tabindex="-1"></a>      <span class="at">lasso_rmse =</span> lasso_rmse,</span>
<span id="cb3-123"><a href="#cb3-123" aria-hidden="true" tabindex="-1"></a>      <span class="at">lasso_r2 =</span> lasso_r2,</span>
<span id="cb3-124"><a href="#cb3-124" aria-hidden="true" tabindex="-1"></a>      <span class="at">ridge_rmse =</span> ridge_rmse,</span>
<span id="cb3-125"><a href="#cb3-125" aria-hidden="true" tabindex="-1"></a>      <span class="at">ridge_r2 =</span> ridge_r2,</span>
<span id="cb3-126"><a href="#cb3-126" aria-hidden="true" tabindex="-1"></a>      <span class="at">lasso_coef =</span> lasso_coef,</span>
<span id="cb3-127"><a href="#cb3-127" aria-hidden="true" tabindex="-1"></a>      <span class="at">ridge_coef =</span> ridge_coef,</span>
<span id="cb3-128"><a href="#cb3-128" aria-hidden="true" tabindex="-1"></a>      <span class="at">predictions =</span> prediction_df</span>
<span id="cb3-129"><a href="#cb3-129" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb3-130"><a href="#cb3-130" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-131"><a href="#cb3-131" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb3-132"><a href="#cb3-132" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(model_results)</span>
<span id="cb3-133"><a href="#cb3-133" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="a.4-clustering-implementation" class="level4">
<h4 class="anchored" data-anchor-id="a.4-clustering-implementation">A.4 Clustering Implementation</h4>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to perform improved clustering analysis</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>improve_clusters <span class="ot">&lt;-</span> <span class="cf">function</span>(stability_data) {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Required packages</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">require</span>(cluster)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">require</span>(factoextra)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">require</span>(ggplot2)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Prepare data for clustering</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  cluster_data <span class="ot">&lt;-</span> stability_data <span class="sc">%&gt;%</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Select relevant features</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">select</span>(token, date, peg_deviation, volatility) <span class="sc">%&gt;%</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create additional features</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">group_by</span>(token) <span class="sc">%&gt;%</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>      <span class="at">deviation_change =</span> peg_deviation <span class="sc">-</span> <span class="fu">lag</span>(peg_deviation, <span class="dv">1</span>),</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>      <span class="at">volatility_change =</span> volatility <span class="sc">-</span> <span class="fu">lag</span>(volatility, <span class="dv">1</span>),</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>      <span class="at">rolling_dev =</span> zoo<span class="sc">::</span><span class="fu">rollmean</span>(peg_deviation, <span class="at">k =</span> <span class="dv">3</span>, <span class="at">fill =</span> <span class="cn">NA</span>, <span class="at">align =</span> <span class="st">"right"</span>),</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>      <span class="at">rolling_vol =</span> zoo<span class="sc">::</span><span class="fu">rollmean</span>(volatility, <span class="at">k =</span> <span class="dv">3</span>, <span class="at">fill =</span> <span class="cn">NA</span>, <span class="at">align =</span> <span class="st">"right"</span>),</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>      <span class="at">dev_vol_interaction =</span> peg_deviation <span class="sc">*</span> volatility</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    ) <span class="sc">%&gt;%</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ungroup</span>() <span class="sc">%&gt;%</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Remove rows with NA values</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(deviation_change), <span class="sc">!</span><span class="fu">is.na</span>(volatility_change),</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>           <span class="sc">!</span><span class="fu">is.na</span>(rolling_dev), <span class="sc">!</span><span class="fu">is.na</span>(rolling_vol))</span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Extract features for clustering</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>  features <span class="ot">&lt;-</span> cluster_data <span class="sc">%&gt;%</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    <span class="fu">select</span>(peg_deviation, volatility, deviation_change, volatility_change,</span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>           rolling_dev, rolling_vol, dev_vol_interaction)</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Scale features</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>  scaled_features <span class="ot">&lt;-</span> <span class="fu">scale</span>(features)</span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Perform PCA</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>  pca_result <span class="ot">&lt;-</span> <span class="fu">prcomp</span>(scaled_features)</span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Determine optimal number of clusters</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>  silhouette_scores <span class="ot">&lt;-</span> <span class="fu">sapply</span>(<span class="dv">2</span><span class="sc">:</span><span class="dv">10</span>, <span class="cf">function</span>(k) {</span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    km <span class="ot">&lt;-</span> <span class="fu">kmeans</span>(pca_result<span class="sc">$</span>x[, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>], <span class="at">centers =</span> k, <span class="at">nstart =</span> <span class="dv">25</span>)</span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    ss <span class="ot">&lt;-</span> <span class="fu">silhouette</span>(km<span class="sc">$</span>cluster, <span class="fu">dist</span>(pca_result<span class="sc">$</span>x[, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>]))</span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mean</span>(ss[, <span class="dv">3</span>])</span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>  optimal_k <span class="ot">&lt;-</span> <span class="fu">which.max</span>(silhouette_scores) <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Perform k-means clustering with optimal k</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>  km <span class="ot">&lt;-</span> <span class="fu">kmeans</span>(pca_result<span class="sc">$</span>x[, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>], <span class="at">centers =</span> optimal_k, <span class="at">nstart =</span> <span class="dv">25</span>)</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Add cluster assignments to data</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>  cluster_data<span class="sc">$</span>cluster <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(km<span class="sc">$</span>cluster)</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Create PCA visualization</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>  pca_data <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(pca_result<span class="sc">$</span>x[, <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>])</span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>  pca_data<span class="sc">$</span>token <span class="ot">&lt;-</span> cluster_data<span class="sc">$</span>token</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>  pca_data<span class="sc">$</span>cluster <span class="ot">&lt;-</span> cluster_data<span class="sc">$</span>cluster</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>  pca_data<span class="sc">$</span>date <span class="ot">&lt;-</span> cluster_data<span class="sc">$</span>date</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>  p1 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(pca_data, <span class="fu">aes</span>(<span class="at">x =</span> PC1, <span class="at">y =</span> PC2, <span class="at">color =</span> token, <span class="at">shape =</span> cluster)) <span class="sc">+</span></span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">alpha =</span> <span class="fl">0.7</span>) <span class="sc">+</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"PCA: First Two Principal Components"</span>,</span>
<span id="cb4-63"><a href="#cb4-63" aria-hidden="true" tabindex="-1"></a>         <span class="at">x =</span> <span class="fu">paste0</span>(<span class="st">"PC1 ("</span>, <span class="fu">round</span>(<span class="fu">summary</span>(pca_result)<span class="sc">$</span>importance[<span class="dv">2</span>, <span class="dv">1</span>] <span class="sc">*</span> <span class="dv">100</span>, <span class="dv">1</span>), <span class="st">"%)"</span>),</span>
<span id="cb4-64"><a href="#cb4-64" aria-hidden="true" tabindex="-1"></a>         <span class="at">y =</span> <span class="fu">paste0</span>(<span class="st">"PC2 ("</span>, <span class="fu">round</span>(<span class="fu">summary</span>(pca_result)<span class="sc">$</span>importance[<span class="dv">2</span>, <span class="dv">2</span>] <span class="sc">*</span> <span class="dv">100</span>, <span class="dv">1</span>), <span class="st">"%)"</span>)) <span class="sc">+</span></span>
<span id="cb4-65"><a href="#cb4-65" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb4-66"><a href="#cb4-66" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_color_viridis_d</span>()</span>
<span id="cb4-67"><a href="#cb4-67" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-68"><a href="#cb4-68" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Save PCA plot</span></span>
<span id="cb4-69"><a href="#cb4-69" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggsave</span>(<span class="st">"img/improved_clusters/pca_pc1_pc2.png"</span>, p1, <span class="at">width =</span> <span class="dv">10</span>, <span class="at">height =</span> <span class="dv">8</span>)</span>
<span id="cb4-70"><a href="#cb4-70" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-71"><a href="#cb4-71" aria-hidden="true" tabindex="-1"></a>  p2 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(pca_data, <span class="fu">aes</span>(<span class="at">x =</span> PC1, <span class="at">y =</span> PC3, <span class="at">color =</span> token, <span class="at">shape =</span> cluster)) <span class="sc">+</span></span>
<span id="cb4-72"><a href="#cb4-72" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">alpha =</span> <span class="fl">0.7</span>) <span class="sc">+</span></span>
<span id="cb4-73"><a href="#cb4-73" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"PCA: Components 1 and 3"</span>,</span>
<span id="cb4-74"><a href="#cb4-74" aria-hidden="true" tabindex="-1"></a>         <span class="at">x =</span> <span class="fu">paste0</span>(<span class="st">"PC1 ("</span>, <span class="fu">round</span>(<span class="fu">summary</span>(pca_result)<span class="sc">$</span>importance[<span class="dv">2</span>, <span class="dv">1</span>] <span class="sc">*</span> <span class="dv">100</span>, <span class="dv">1</span>), <span class="st">"%)"</span>),</span>
<span id="cb4-75"><a href="#cb4-75" aria-hidden="true" tabindex="-1"></a>         <span class="at">y =</span> <span class="fu">paste0</span>(<span class="st">"PC3 ("</span>, <span class="fu">round</span>(<span class="fu">summary</span>(pca_result)<span class="sc">$</span>importance[<span class="dv">2</span>, <span class="dv">3</span>] <span class="sc">*</span> <span class="dv">100</span>, <span class="dv">1</span>), <span class="st">"%)"</span>)) <span class="sc">+</span></span>
<span id="cb4-76"><a href="#cb4-76" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb4-77"><a href="#cb4-77" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_color_viridis_d</span>()</span>
<span id="cb4-78"><a href="#cb4-78" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-79"><a href="#cb4-79" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Save PCA plot</span></span>
<span id="cb4-80"><a href="#cb4-80" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggsave</span>(<span class="st">"img/improved_clusters/pca_pc1_pc3.png"</span>, p2, <span class="at">width =</span> <span class="dv">10</span>, <span class="at">height =</span> <span class="dv">8</span>)</span>
<span id="cb4-81"><a href="#cb4-81" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-82"><a href="#cb4-82" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Analyze temporal distribution of clusters</span></span>
<span id="cb4-83"><a href="#cb4-83" aria-hidden="true" tabindex="-1"></a>  temporal_data <span class="ot">&lt;-</span> cluster_data <span class="sc">%&gt;%</span></span>
<span id="cb4-84"><a href="#cb4-84" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">period =</span> <span class="fu">case_when</span>(</span>
<span id="cb4-85"><a href="#cb4-85" aria-hidden="true" tabindex="-1"></a>      date <span class="sc">&lt;</span> <span class="fu">as.Date</span>(<span class="st">"2022-05-08"</span>) <span class="sc">~</span> <span class="st">"Pre-crash"</span>,</span>
<span id="cb4-86"><a href="#cb4-86" aria-hidden="true" tabindex="-1"></a>      date <span class="sc">&gt;=</span> <span class="fu">as.Date</span>(<span class="st">"2022-05-08"</span>) <span class="sc">&amp;</span> date <span class="sc">&lt;=</span> <span class="fu">as.Date</span>(<span class="st">"2022-05-15"</span>) <span class="sc">~</span> <span class="st">"Crash"</span>,</span>
<span id="cb4-87"><a href="#cb4-87" aria-hidden="true" tabindex="-1"></a>      date <span class="sc">&gt;</span> <span class="fu">as.Date</span>(<span class="st">"2022-05-15"</span>) <span class="sc">~</span> <span class="st">"Post-crash"</span></span>
<span id="cb4-88"><a href="#cb4-88" aria-hidden="true" tabindex="-1"></a>    )) <span class="sc">%&gt;%</span></span>
<span id="cb4-89"><a href="#cb4-89" aria-hidden="true" tabindex="-1"></a>    <span class="fu">mutate</span>(<span class="at">period =</span> <span class="fu">factor</span>(period, <span class="at">levels =</span> <span class="fu">c</span>(<span class="st">"Pre-crash"</span>, <span class="st">"Crash"</span>, <span class="st">"Post-crash"</span>)))</span>
<span id="cb4-90"><a href="#cb4-90" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-91"><a href="#cb4-91" aria-hidden="true" tabindex="-1"></a>  p3 <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(temporal_data, <span class="fu">aes</span>(<span class="at">x =</span> date, <span class="at">y =</span> token, <span class="at">fill =</span> cluster)) <span class="sc">+</span></span>
<span id="cb4-92"><a href="#cb4-92" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_tile</span>() <span class="sc">+</span></span>
<span id="cb4-93"><a href="#cb4-93" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Temporal Distribution of Clusters"</span>,</span>
<span id="cb4-94"><a href="#cb4-94" aria-hidden="true" tabindex="-1"></a>         <span class="at">x =</span> <span class="st">"Date"</span>,</span>
<span id="cb4-95"><a href="#cb4-95" aria-hidden="true" tabindex="-1"></a>         <span class="at">y =</span> <span class="st">"Token"</span>,</span>
<span id="cb4-96"><a href="#cb4-96" aria-hidden="true" tabindex="-1"></a>         <span class="at">fill =</span> <span class="st">"Cluster"</span>) <span class="sc">+</span></span>
<span id="cb4-97"><a href="#cb4-97" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb4-98"><a href="#cb4-98" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_fill_viridis_d</span>() <span class="sc">+</span></span>
<span id="cb4-99"><a href="#cb4-99" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="fu">as.numeric</span>(<span class="fu">as.Date</span>(<span class="st">"2022-05-08"</span>)), </span>
<span id="cb4-100"><a href="#cb4-100" aria-hidden="true" tabindex="-1"></a>               <span class="at">linetype =</span> <span class="st">"dashed"</span>, <span class="at">color =</span> <span class="st">"red"</span>) <span class="sc">+</span></span>
<span id="cb4-101"><a href="#cb4-101" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="fu">as.numeric</span>(<span class="fu">as.Date</span>(<span class="st">"2022-05-15"</span>)), </span>
<span id="cb4-102"><a href="#cb4-102" aria-hidden="true" tabindex="-1"></a>               <span class="at">linetype =</span> <span class="st">"dashed"</span>, <span class="at">color =</span> <span class="st">"red"</span>)</span>
<span id="cb4-103"><a href="#cb4-103" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-104"><a href="#cb4-104" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Save temporal distribution plot</span></span>
<span id="cb4-105"><a href="#cb4-105" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggsave</span>(<span class="st">"img/improved_clusters/temporal_distribution.png"</span>, p3, </span>
<span id="cb4-106"><a href="#cb4-106" aria-hidden="true" tabindex="-1"></a>         <span class="at">width =</span> <span class="dv">12</span>, <span class="at">height =</span> <span class="dv">6</span>)</span>
<span id="cb4-107"><a href="#cb4-107" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-108"><a href="#cb4-108" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Analyze cluster characteristics</span></span>
<span id="cb4-109"><a href="#cb4-109" aria-hidden="true" tabindex="-1"></a>  cluster_stats <span class="ot">&lt;-</span> cluster_data <span class="sc">%&gt;%</span></span>
<span id="cb4-110"><a href="#cb4-110" aria-hidden="true" tabindex="-1"></a>    <span class="fu">group_by</span>(cluster) <span class="sc">%&gt;%</span></span>
<span id="cb4-111"><a href="#cb4-111" aria-hidden="true" tabindex="-1"></a>    <span class="fu">summarize</span>(</span>
<span id="cb4-112"><a href="#cb4-112" aria-hidden="true" tabindex="-1"></a>      <span class="at">count =</span> <span class="fu">n</span>(),</span>
<span id="cb4-113"><a href="#cb4-113" aria-hidden="true" tabindex="-1"></a>      <span class="at">mean_deviation =</span> <span class="fu">mean</span>(peg_deviation),</span>
<span id="cb4-114"><a href="#cb4-114" aria-hidden="true" tabindex="-1"></a>      <span class="at">mean_volatility =</span> <span class="fu">mean</span>(volatility),</span>
<span id="cb4-115"><a href="#cb4-115" aria-hidden="true" tabindex="-1"></a>      <span class="at">mean_dev_change =</span> <span class="fu">mean</span>(deviation_change),</span>
<span id="cb4-116"><a href="#cb4-116" aria-hidden="true" tabindex="-1"></a>      <span class="at">mean_vol_change =</span> <span class="fu">mean</span>(volatility_change)</span>
<span id="cb4-117"><a href="#cb4-117" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb4-118"><a href="#cb4-118" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-119"><a href="#cb4-119" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Analyze token distribution across clusters</span></span>
<span id="cb4-120"><a href="#cb4-120" aria-hidden="true" tabindex="-1"></a>  token_cluster_dist <span class="ot">&lt;-</span> cluster_data <span class="sc">%&gt;%</span></span>
<span id="cb4-121"><a href="#cb4-121" aria-hidden="true" tabindex="-1"></a>    <span class="fu">group_by</span>(token, cluster) <span class="sc">%&gt;%</span></span>
<span id="cb4-122"><a href="#cb4-122" aria-hidden="true" tabindex="-1"></a>    <span class="fu">summarize</span>(<span class="at">count =</span> <span class="fu">n</span>(), <span class="at">.groups =</span> <span class="st">"drop"</span>) <span class="sc">%&gt;%</span></span>
<span id="cb4-123"><a href="#cb4-123" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pivot_wider</span>(<span class="at">names_from =</span> cluster, <span class="at">values_from =</span> count, <span class="at">values_fill =</span> <span class="dv">0</span>)</span>
<span id="cb4-124"><a href="#cb4-124" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb4-125"><a href="#cb4-125" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Return results</span></span>
<span id="cb4-126"><a href="#cb4-126" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(</span>
<span id="cb4-127"><a href="#cb4-127" aria-hidden="true" tabindex="-1"></a>    <span class="at">pca_result =</span> pca_result,</span>
<span id="cb4-128"><a href="#cb4-128" aria-hidden="true" tabindex="-1"></a>    <span class="at">cluster_result =</span> km,</span>
<span id="cb4-129"><a href="#cb4-129" aria-hidden="true" tabindex="-1"></a>    <span class="at">cluster_data =</span> cluster_data,</span>
<span id="cb4-130"><a href="#cb4-130" aria-hidden="true" tabindex="-1"></a>    <span class="at">optimal_k =</span> optimal_k,</span>
<span id="cb4-131"><a href="#cb4-131" aria-hidden="true" tabindex="-1"></a>    <span class="at">silhouette_score =</span> silhouette_scores[optimal_k <span class="sc">-</span> <span class="dv">1</span>],</span>
<span id="cb4-132"><a href="#cb4-132" aria-hidden="true" tabindex="-1"></a>    <span class="at">cluster_stats =</span> cluster_stats,</span>
<span id="cb4-133"><a href="#cb4-133" aria-hidden="true" tabindex="-1"></a>    <span class="at">token_cluster_dist =</span> token_cluster_dist</span>
<span id="cb4-134"><a href="#cb4-134" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb4-135"><a href="#cb4-135" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="a.5-model-comparison-implementation" class="level4">
<h4 class="anchored" data-anchor-id="a.5-model-comparison-implementation">A.5 Model Comparison Implementation</h4>
<div class="sourceCode" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to compare model performance across tokens</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>compare_models <span class="ot">&lt;-</span> <span class="cf">function</span>(tree_results, forest_results, model_results) {</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Initialize performance data frame</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  performance_data <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">model =</span> <span class="fu">character</span>(),</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">token =</span> <span class="fu">character</span>(),</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">accuracy =</span> <span class="fu">numeric</span>(),</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">r_squared =</span> <span class="fu">numeric</span>(),</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">rmse =</span> <span class="fu">numeric</span>(),</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">auc =</span> <span class="fu">numeric</span>(),</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Extract metrics from tree results</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(tree_results)) {</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (token <span class="cf">in</span> <span class="fu">names</span>(tree_results)) {</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(tree_results[[token]])) {</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        performance_data <span class="ot">&lt;-</span> <span class="fu">rbind</span>(performance_data, <span class="fu">data.frame</span>(</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>          <span class="at">model =</span> <span class="st">"Decision Tree"</span>,</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>          <span class="at">token =</span> token,</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>          <span class="at">accuracy =</span> <span class="fu">ifelse</span>(<span class="fu">is.null</span>(tree_results[[token]]<span class="sc">$</span>accuracy), <span class="cn">NA</span>, tree_results[[token]]<span class="sc">$</span>accuracy),</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>          <span class="at">r_squared =</span> <span class="cn">NA</span>,</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>          <span class="at">rmse =</span> <span class="cn">NA</span>,</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>          <span class="at">auc =</span> <span class="fu">ifelse</span>(<span class="fu">is.null</span>(tree_results[[token]]<span class="sc">$</span>auc), <span class="cn">NA</span>, tree_results[[token]]<span class="sc">$</span>auc),</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>          <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        ))</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Extract metrics from forest results</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(forest_results)) {</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (token <span class="cf">in</span> <span class="fu">names</span>(forest_results)) {</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(forest_results[[token]])) {</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        performance_data <span class="ot">&lt;-</span> <span class="fu">rbind</span>(performance_data, <span class="fu">data.frame</span>(</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>          <span class="at">model =</span> <span class="st">"Random Forest"</span>,</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>          <span class="at">token =</span> token,</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>          <span class="at">accuracy =</span> <span class="cn">NA</span>,</span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>          <span class="at">r_squared =</span> <span class="fu">ifelse</span>(<span class="fu">is.null</span>(forest_results[[token]]<span class="sc">$</span>r_squared), <span class="cn">NA</span>, forest_results[[token]]<span class="sc">$</span>r_squared),</span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>          <span class="at">rmse =</span> <span class="fu">ifelse</span>(<span class="fu">is.null</span>(forest_results[[token]]<span class="sc">$</span>rmse), <span class="cn">NA</span>, forest_results[[token]]<span class="sc">$</span>rmse),</span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>          <span class="at">auc =</span> <span class="cn">NA</span>,</span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>          <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>        ))</span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb5-45"><a href="#cb5-45" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb5-46"><a href="#cb5-46" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb5-47"><a href="#cb5-47" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-48"><a href="#cb5-48" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Extract metrics from LASSO/Ridge results</span></span>
<span id="cb5-49"><a href="#cb5-49" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(model_results)) {</span>
<span id="cb5-50"><a href="#cb5-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> (token <span class="cf">in</span> <span class="fu">names</span>(model_results)) {</span>
<span id="cb5-51"><a href="#cb5-51" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(model_results[[token]])) {</span>
<span id="cb5-52"><a href="#cb5-52" aria-hidden="true" tabindex="-1"></a>        <span class="co"># LASSO metrics</span></span>
<span id="cb5-53"><a href="#cb5-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(model_results[[token]]<span class="sc">$</span>lasso_r2)) {</span>
<span id="cb5-54"><a href="#cb5-54" aria-hidden="true" tabindex="-1"></a>          performance_data <span class="ot">&lt;-</span> <span class="fu">rbind</span>(performance_data, <span class="fu">data.frame</span>(</span>
<span id="cb5-55"><a href="#cb5-55" aria-hidden="true" tabindex="-1"></a>            <span class="at">model =</span> <span class="st">"LASSO"</span>,</span>
<span id="cb5-56"><a href="#cb5-56" aria-hidden="true" tabindex="-1"></a>            <span class="at">token =</span> token,</span>
<span id="cb5-57"><a href="#cb5-57" aria-hidden="true" tabindex="-1"></a>            <span class="at">accuracy =</span> <span class="cn">NA</span>,</span>
<span id="cb5-58"><a href="#cb5-58" aria-hidden="true" tabindex="-1"></a>            <span class="at">r_squared =</span> model_results[[token]]<span class="sc">$</span>lasso_r2,</span>
<span id="cb5-59"><a href="#cb5-59" aria-hidden="true" tabindex="-1"></a>            <span class="at">rmse =</span> <span class="fu">ifelse</span>(<span class="fu">is.null</span>(model_results[[token]]<span class="sc">$</span>lasso_rmse), <span class="cn">NA</span>, model_results[[token]]<span class="sc">$</span>lasso_rmse),</span>
<span id="cb5-60"><a href="#cb5-60" aria-hidden="true" tabindex="-1"></a>            <span class="at">auc =</span> <span class="cn">NA</span>,</span>
<span id="cb5-61"><a href="#cb5-61" aria-hidden="true" tabindex="-1"></a>            <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb5-62"><a href="#cb5-62" aria-hidden="true" tabindex="-1"></a>          ))</span>
<span id="cb5-63"><a href="#cb5-63" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb5-64"><a href="#cb5-64" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-65"><a href="#cb5-65" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Ridge metrics</span></span>
<span id="cb5-66"><a href="#cb5-66" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(model_results[[token]]<span class="sc">$</span>ridge_r2)) {</span>
<span id="cb5-67"><a href="#cb5-67" aria-hidden="true" tabindex="-1"></a>          performance_data <span class="ot">&lt;-</span> <span class="fu">rbind</span>(performance_data, <span class="fu">data.frame</span>(</span>
<span id="cb5-68"><a href="#cb5-68" aria-hidden="true" tabindex="-1"></a>            <span class="at">model =</span> <span class="st">"Ridge"</span>,</span>
<span id="cb5-69"><a href="#cb5-69" aria-hidden="true" tabindex="-1"></a>            <span class="at">token =</span> token,</span>
<span id="cb5-70"><a href="#cb5-70" aria-hidden="true" tabindex="-1"></a>            <span class="at">accuracy =</span> <span class="cn">NA</span>,</span>
<span id="cb5-71"><a href="#cb5-71" aria-hidden="true" tabindex="-1"></a>            <span class="at">r_squared =</span> model_results[[token]]<span class="sc">$</span>ridge_r2,</span>
<span id="cb5-72"><a href="#cb5-72" aria-hidden="true" tabindex="-1"></a>            <span class="at">rmse =</span> <span class="fu">ifelse</span>(<span class="fu">is.null</span>(model_results[[token]]<span class="sc">$</span>ridge_rmse), <span class="cn">NA</span>, model_results[[token]]<span class="sc">$</span>ridge_rmse),</span>
<span id="cb5-73"><a href="#cb5-73" aria-hidden="true" tabindex="-1"></a>            <span class="at">auc =</span> <span class="cn">NA</span>,</span>
<span id="cb5-74"><a href="#cb5-74" aria-hidden="true" tabindex="-1"></a>            <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb5-75"><a href="#cb5-75" aria-hidden="true" tabindex="-1"></a>          ))</span>
<span id="cb5-76"><a href="#cb5-76" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb5-77"><a href="#cb5-77" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb5-78"><a href="#cb5-78" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb5-79"><a href="#cb5-79" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb5-80"><a href="#cb5-80" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-81"><a href="#cb5-81" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Create comparison visualizations</span></span>
<span id="cb5-82"><a href="#cb5-82" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-83"><a href="#cb5-83" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 1. R-squared comparison</span></span>
<span id="cb5-84"><a href="#cb5-84" aria-hidden="true" tabindex="-1"></a>  p1 <span class="ot">&lt;-</span> performance_data <span class="sc">%&gt;%</span></span>
<span id="cb5-85"><a href="#cb5-85" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(r_squared)) <span class="sc">%&gt;%</span></span>
<span id="cb5-86"><a href="#cb5-86" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> token, <span class="at">y =</span> r_squared, <span class="at">fill =</span> model)) <span class="sc">+</span></span>
<span id="cb5-87"><a href="#cb5-87" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_bar</span>(<span class="at">stat =</span> <span class="st">"identity"</span>, <span class="at">position =</span> <span class="fu">position_dodge</span>(<span class="at">width =</span> <span class="fl">0.9</span>)) <span class="sc">+</span></span>
<span id="cb5-88"><a href="#cb5-88" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_text</span>(<span class="fu">aes</span>(<span class="at">label =</span> <span class="fu">sprintf</span>(<span class="st">"%.2f"</span>, r_squared)),</span>
<span id="cb5-89"><a href="#cb5-89" aria-hidden="true" tabindex="-1"></a>              <span class="at">position =</span> <span class="fu">position_dodge</span>(<span class="at">width =</span> <span class="fl">0.9</span>),</span>
<span id="cb5-90"><a href="#cb5-90" aria-hidden="true" tabindex="-1"></a>              <span class="at">vjust =</span> <span class="sc">-</span><span class="fl">0.5</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb5-91"><a href="#cb5-91" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_y_continuous</span>(<span class="at">expand =</span> <span class="fu">expansion</span>(<span class="at">mult =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.2</span>))) <span class="sc">+</span></span>
<span id="cb5-92"><a href="#cb5-92" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Model Explanatory Power"</span>,</span>
<span id="cb5-93"><a href="#cb5-93" aria-hidden="true" tabindex="-1"></a>         <span class="at">subtitle =</span> <span class="st">"Higher R² indicates better variance explanation"</span>,</span>
<span id="cb5-94"><a href="#cb5-94" aria-hidden="true" tabindex="-1"></a>         <span class="at">x =</span> <span class="st">"Stablecoin"</span>, </span>
<span id="cb5-95"><a href="#cb5-95" aria-hidden="true" tabindex="-1"></a>         <span class="at">y =</span> <span class="st">"R-squared"</span>,</span>
<span id="cb5-96"><a href="#cb5-96" aria-hidden="true" tabindex="-1"></a>         <span class="at">fill =</span> <span class="st">"Model Type"</span>) <span class="sc">+</span></span>
<span id="cb5-97"><a href="#cb5-97" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_fill_viridis_d</span>() <span class="sc">+</span></span>
<span id="cb5-98"><a href="#cb5-98" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb5-99"><a href="#cb5-99" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme</span>(</span>
<span id="cb5-100"><a href="#cb5-100" aria-hidden="true" tabindex="-1"></a>      <span class="at">axis.text.x =</span> <span class="fu">element_text</span>(<span class="at">angle =</span> <span class="dv">45</span>, <span class="at">hjust =</span> <span class="dv">1</span>),</span>
<span id="cb5-101"><a href="#cb5-101" aria-hidden="true" tabindex="-1"></a>      <span class="at">legend.position =</span> <span class="st">"bottom"</span>,</span>
<span id="cb5-102"><a href="#cb5-102" aria-hidden="true" tabindex="-1"></a>      <span class="at">panel.grid.minor =</span> <span class="fu">element_blank</span>()</span>
<span id="cb5-103"><a href="#cb5-103" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb5-104"><a href="#cb5-104" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-105"><a href="#cb5-105" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Save plot</span></span>
<span id="cb5-106"><a href="#cb5-106" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggsave</span>(<span class="st">"img/comparison/model_explanatory_power.png"</span>, p1, <span class="at">width =</span> <span class="dv">12</span>, <span class="at">height =</span> <span class="dv">8</span>)</span>
<span id="cb5-107"><a href="#cb5-107" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-108"><a href="#cb5-108" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 2. RMSE comparison</span></span>
<span id="cb5-109"><a href="#cb5-109" aria-hidden="true" tabindex="-1"></a>  p2 <span class="ot">&lt;-</span> performance_data <span class="sc">%&gt;%</span></span>
<span id="cb5-110"><a href="#cb5-110" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(rmse)) <span class="sc">%&gt;%</span></span>
<span id="cb5-111"><a href="#cb5-111" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> token, <span class="at">y =</span> rmse, <span class="at">fill =</span> model)) <span class="sc">+</span></span>
<span id="cb5-112"><a href="#cb5-112" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_bar</span>(<span class="at">stat =</span> <span class="st">"identity"</span>, <span class="at">position =</span> <span class="fu">position_dodge</span>(<span class="at">width =</span> <span class="fl">0.9</span>)) <span class="sc">+</span></span>
<span id="cb5-113"><a href="#cb5-113" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_text</span>(<span class="fu">aes</span>(<span class="at">label =</span> <span class="fu">sprintf</span>(<span class="st">"%.5f"</span>, rmse)),</span>
<span id="cb5-114"><a href="#cb5-114" aria-hidden="true" tabindex="-1"></a>              <span class="at">position =</span> <span class="fu">position_dodge</span>(<span class="at">width =</span> <span class="fl">0.9</span>),</span>
<span id="cb5-115"><a href="#cb5-115" aria-hidden="true" tabindex="-1"></a>              <span class="at">vjust =</span> <span class="sc">-</span><span class="fl">0.5</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb5-116"><a href="#cb5-116" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_y_continuous</span>(<span class="at">expand =</span> <span class="fu">expansion</span>(<span class="at">mult =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.2</span>))) <span class="sc">+</span></span>
<span id="cb5-117"><a href="#cb5-117" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Model Performance Comparison"</span>,</span>
<span id="cb5-118"><a href="#cb5-118" aria-hidden="true" tabindex="-1"></a>         <span class="at">subtitle =</span> <span class="st">"Lower RMSE indicates better prediction accuracy"</span>,</span>
<span id="cb5-119"><a href="#cb5-119" aria-hidden="true" tabindex="-1"></a>         <span class="at">x =</span> <span class="st">"Stablecoin"</span>, </span>
<span id="cb5-120"><a href="#cb5-120" aria-hidden="true" tabindex="-1"></a>         <span class="at">y =</span> <span class="st">"RMSE (Root Mean Square Error)"</span>,</span>
<span id="cb5-121"><a href="#cb5-121" aria-hidden="true" tabindex="-1"></a>         <span class="at">fill =</span> <span class="st">"Model Type"</span>) <span class="sc">+</span></span>
<span id="cb5-122"><a href="#cb5-122" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_fill_viridis_d</span>() <span class="sc">+</span></span>
<span id="cb5-123"><a href="#cb5-123" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb5-124"><a href="#cb5-124" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme</span>(</span>
<span id="cb5-125"><a href="#cb5-125" aria-hidden="true" tabindex="-1"></a>      <span class="at">axis.text.x =</span> <span class="fu">element_text</span>(<span class="at">angle =</span> <span class="dv">45</span>, <span class="at">hjust =</span> <span class="dv">1</span>),</span>
<span id="cb5-126"><a href="#cb5-126" aria-hidden="true" tabindex="-1"></a>      <span class="at">legend.position =</span> <span class="st">"bottom"</span>,</span>
<span id="cb5-127"><a href="#cb5-127" aria-hidden="true" tabindex="-1"></a>      <span class="at">panel.grid.minor =</span> <span class="fu">element_blank</span>()</span>
<span id="cb5-128"><a href="#cb5-128" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb5-129"><a href="#cb5-129" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-130"><a href="#cb5-130" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Save plot</span></span>
<span id="cb5-131"><a href="#cb5-131" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggsave</span>(<span class="st">"img/comparison/model_performance_comparison.png"</span>, p2, <span class="at">width =</span> <span class="dv">12</span>, <span class="at">height =</span> <span class="dv">8</span>)</span>
<span id="cb5-132"><a href="#cb5-132" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-133"><a href="#cb5-133" aria-hidden="true" tabindex="-1"></a>  <span class="co"># 3. R² vs RMSE Scatterplot</span></span>
<span id="cb5-134"><a href="#cb5-134" aria-hidden="true" tabindex="-1"></a>  p3 <span class="ot">&lt;-</span> performance_data <span class="sc">%&gt;%</span></span>
<span id="cb5-135"><a href="#cb5-135" aria-hidden="true" tabindex="-1"></a>    <span class="fu">filter</span>(<span class="sc">!</span><span class="fu">is.na</span>(r_squared) <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(rmse)) <span class="sc">%&gt;%</span></span>
<span id="cb5-136"><a href="#cb5-136" aria-hidden="true" tabindex="-1"></a>    <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> r_squared, <span class="at">y =</span> rmse, <span class="at">color =</span> token, <span class="at">shape =</span> model)) <span class="sc">+</span></span>
<span id="cb5-137"><a href="#cb5-137" aria-hidden="true" tabindex="-1"></a>    <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="dv">3</span>, <span class="at">alpha =</span> <span class="fl">0.7</span>) <span class="sc">+</span></span>
<span id="cb5-138"><a href="#cb5-138" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb5-139"><a href="#cb5-139" aria-hidden="true" tabindex="-1"></a>    <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Model Performance Summary"</span>,</span>
<span id="cb5-140"><a href="#cb5-140" aria-hidden="true" tabindex="-1"></a>         <span class="at">x =</span> <span class="st">"R² Value"</span>,</span>
<span id="cb5-141"><a href="#cb5-141" aria-hidden="true" tabindex="-1"></a>         <span class="at">y =</span> <span class="st">"RMSE"</span>,</span>
<span id="cb5-142"><a href="#cb5-142" aria-hidden="true" tabindex="-1"></a>         <span class="at">color =</span> <span class="st">"Token"</span>,</span>
<span id="cb5-143"><a href="#cb5-143" aria-hidden="true" tabindex="-1"></a>         <span class="at">shape =</span> <span class="st">"Model Type"</span>) <span class="sc">+</span></span>
<span id="cb5-144"><a href="#cb5-144" aria-hidden="true" tabindex="-1"></a>    <span class="fu">scale_color_viridis_d</span>() <span class="sc">+</span></span>
<span id="cb5-145"><a href="#cb5-145" aria-hidden="true" tabindex="-1"></a>    <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"right"</span>)</span>
<span id="cb5-146"><a href="#cb5-146" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-147"><a href="#cb5-147" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Save plot</span></span>
<span id="cb5-148"><a href="#cb5-148" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggsave</span>(<span class="st">"img/comparison/performance_summary.png"</span>, p3, <span class="at">width =</span> <span class="dv">10</span>, <span class="at">height =</span> <span class="dv">8</span>)</span>
<span id="cb5-149"><a href="#cb5-149" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb5-150"><a href="#cb5-150" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Return performance data</span></span>
<span id="cb5-151"><a href="#cb5-151" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(performance_data)</span>
<span id="cb5-152"><a href="#cb5-152" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>